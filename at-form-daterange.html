<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="at-form-daterange-dropdown.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-carbon-icon/at-carbon-icon.html">
<link rel="import" href="../at-form-behaviors/at-form-behaviors-validation.html">

<!-- This is a new component extracted from the demo.html for polymer 0.5 -->

<dom-module id="at-form-daterange">
  <template>
    <style include="at-form-common"></style>
    <style>
      :host * {
        box-sizing: border-box;
      }
       :host {
        @apply(--at-form-host);
      }

      #triggerContainer {
        @apply(--layout-horizontal);
      }

      .icon-background {
        color: var(--at-form-daterange-icon-text-color);
        @apply(at-form-border-radius0220);
      }

    </style>
    <div id="atContainer" class="at-container">
      <label id="label">{{label}}</label>
      <div id="contentContainer" class="at-content-container">
        <div id="triggerContainer" class="input-group">
          <input id="triggerRange" class="at-content has-placeholder" value="{{value}}" on-focus="open" on-blur="close" readonly class="date">
          <i class="icon-background input-group-addon" on-mousedown="_buttonIconClick">
            <at-carbon-icon icon="now:calendar"></at-carbon-icon>
          </i>
        </div>
        <at-form-daterange-dropdown id="dateRangePicker" disabled$={{disabled}} show-ranges format="[[format]]" start-date="{{startDate}}" end-date="{{endDate}}"></at-form-daterange-dropdown>
      </div>
      <div id="hint"></div>
    </div>
  </template>
</dom-module>

<script>
  (function (utils) {
    utils.isChildOf = function (child, parent) {
      var isChild = false;
      var iterElem = child
        ? child
        : null;

      while (!isChild && iterElem !== null && iterElem.nodeType !== 9) {
        isChild = iterElem === parent;
        iterElem = iterElem.parentElement;
      }

      return isChild;
    }
  }(window.afDateRangeUtils = window.afDateRangeUtils || {}));

  Polymer({
    is: 'at-form-daterange',
    behaviors: [
      Tangere.behaviors.formValidation, Tangere.behaviors.i18n
    ],
    properties: {
      label: {
        type: String,
        value: '',
        title: 'Label'
      },
      hideLabel: {
        type: Boolean,
        value: false,
        observer: 'hideLabelChanged',
        title: 'Do not show the label'
      },
      startDate: {
        type: String,
        value: '',
        notify: true,
        observer: 'startDateChanged'
      },
      endDate: {
        type: String,
        value: '',
        notify: true,
        observer: 'endDateChanged'
      },
      value: {
        type: String,
        computed: 'computeValue(startDate, endDate)',
        notify: true,
        isReadOnly: true,
        title: 'Value'
      },
      required: {
        type: Boolean,
        value: false,
        observer: 'requiredChanged',
        title: 'Input required'
      },
      disabled: {
        type: Boolean,
        value: false,
        observer: 'disabledChanged',
        title: 'Field value can not be changed'
      },
      /**
       * Hides the element. When hidden nothing is displayed for the element
       * @property hide
       * @type Boolean
       * @default false
       */
      hide: {
        type: Boolean,
        value: false,
        observer: 'hideChanged',
        title: 'Field is invisible'
      },
      format: {
        type: String,
        value: '',
        observer: 'formatChanged',
        title: 'Format'
      }
    },
    $meta: [
      {
        title: "Daterange",
        type: "daterange"
      }
    ],
    ready: function () {
      this._isReady = false;
      this._internalFormat = this._localizedFormat("date");
      var self = this;
      var triggerRange = this.$.triggerRange;
      var unboundFunction = function (event) {
        if (triggerRange !== event.target && afDateRangeUtils.isChildOf(event.target, self)) {
          event.preventDefault();
        }
      }

      document.body.addEventListener('mousedown', unboundFunction);

      this._validationFunctions.push(this._validateValueFormat.bind(this));

      this._isReady = true;
    },
    focus: function () {
      var trigger = this.$.triggerRange;
      trigger.focus();
    },
    hideChanged: function (newValue, oldValue) {
      var wrapper = this.$.atContainer;
      this.toggleClass('hidden', newValue, wrapper);
      if (this._isReady) {
        this.validate();
      }
    },
    hideLabelChanged: function (newValue, oldValue) {
      var label = this.$.label;
      this.toggleClass("hidden", newValue, label);
    },
    // value is read only
    set value(newValue) {},
    // compute value computes the value from startDate and endDate
    computeValue: function (startDate, endDate) {
      var valueStringTemplate = this.T("{0} to {1}");
      var result = '';
      if (startDate === "" || endDate === "") { return result; }
      if (startDate && endDate) {
        result = valueStringTemplate.replace("{0}", startDate).replace("{1}", endDate);
      }

      return result;
    },
    open: function (event) {
      console.log('open');
      if (!this.disabled) {
        this.$.dateRangePicker.open(event);
      }
    },
    close: function (event) {
      console.log('close');
      this.$.dateRangePicker.close(event);
    },
    toggle: function (event) {
      if (!this.disabled) {
        // this.$.dateRangePicker.toggle(event);
      }
    },
    _buttonIconClick: function (event) {
      if (!this.disabled) {
        this.$.triggerRange.focus();
      }
    },
    disabledChanged: function (newValue, oldValue) {
      var atContainer = this.$.atContainer;
      this.toggleClass('disabled', newValue, atContainer);
      if (this._isReady) {
        this.validate();
      }
    },
    requiredChanged: function (newValue, oldValue) {
      if (this._isReady) {
        this.validate();
      }
    },
    _updateUIValidState: function (isValid) {
      var label = this.$.label;
      this.toggleClass('error', !isValid, label);
      var contentContainer = this.$.contentContainer;
      this.toggleClass('error', !isValid, contentContainer);
    },
    startDateChanged: function (newValue, oldValue) {
      if (this._isReady) {
        this.validate();
      }
    },
    endDateChanged: function (newValue, oldValue) {
      if (this._isReady) {
        this.validate();
      }
    },
    formatChanged: function (newValue, oldValue) {
      var format = newValue;
      if (format) {
        if (!this._containsChars(['Y', 'M', 'D'], format) || this._containsChars(['h', 'm', 's'], format)) {
          // set format to the default format for date
          format = this._internalFormat;
          // log the error
          console.log('Value ' + newValue + ' is not a valid format for date. Using default, ' + format + ', format instead.');
        }
        this.format = format;
        this.fire('format-changed', {value: format});
        this._internalFormat = format;
      }
    },
    /**
     * checks if source contains any of the chars
     * @param {Array} chars
     * @param {String} source
     */
    _containsChars: function (chars, source) {
      var result = false;
      chars.forEach(function (char, index) {
        result = result || source.indexOf(char) !== -1;
      });
      return result;
    },
    // *ij* the main purpose of this function is to validate startDate and endDate format when they are programmatically set
    _validateValueFormat: function (value) {
      var result = true;
      var valueParts = value.split(' to ');
      var startDate = valueParts[0];
      var endDate = valueParts[1];
      var dateFormat = this._internalFormat;

      var startDateValid = true;
      var endDateValid = true;

      if (value === '') {
        return true;
      }

      if (startDate !== undefined && startDate !== '') {
        startDateValid = moment(startDate, dateFormat).isValid();
      }

      if (endDate !== undefined && endDate !== '') {
        endDateValid = moment(endDate, dateFormat).isValid();
      }

      result = result && startDateValid && endDateValid;

      if (!startDateValid) {
        this._errorMessage = this.T('Start date is in invalid format. Enter start date in format {0}', dateFormat);
      } else if (!endDateValid) {
        this._errorMessage = this.T('End date is in invalid format. Enter end date in format {0}', dateFormat);
      }

      return result;
    },
    _getFocusableElement: function () {
      var focusable = this.$.triggerRange;
      return focusable;
    }
  });
</script>
