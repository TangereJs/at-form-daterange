<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="at-form-daterange-dropdown.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-carbon-icon/at-carbon-icon.html">
<link rel="import" href="../at-form-behaviors/at-form-behaviors.html">
<link rel="import" href="at-form-daterange-input-validation-behavior.html">

<!-- This is a new component extracted from the demo.html for polymer 0.5 -->

<dom-module id="at-form-daterange">
  <template>
    <style include="at-form-common"></style>
    <style>
      :host * {
        box-sizing: border-box;
      }

      :host {
        @apply(--at-form-host);
      }

      #triggerContainer {
        @apply(--layout-horizontal);
      }

      .icon-background {
        color: var(--at-form-daterange-icon-text-color);
        @apply(at-form-border-radius0220);
      }

      .dropdown-container {
        position: relative;
        display: block;
      }

      .core-dropdown .ranges {
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        padding: 4px 8px;
        margin: 4px;
        min-width: 175px;
      }

      .range-item {
        padding: 4px 8px;
        margin: 2px 0;
        cursor: pointer;
        border-radius: 5px;
        @apply(--at-form-label-font);
        @apply(--at-text-selected);
      }

      .core-dropdown .ranges .range-item.active,
      .core-dropdown .ranges .range-item:hover {
        @apply(--at-text-primary-selected);
      }

      .hidden {
        display: none;
      }
    </style>
    <div id="atContainer" class="at-container">
      <label id="label">{{label}}</label>
      <div id="contentContainer" class="at-content-container">
        <div id="triggerContainer" class="input-group">
          <input id="triggerRange" class="at-content has-placeholder date" on-mousedown="_triggerRangeMouseDown" readonly>
          <at-carbon-icon-button id="triggerRangeIcon" class="icon-background input-group-addon" on-mousedown="_iconButtonMouseDown" icon="now:calendar"></at-carbon-icon-button>
        </div>
        <at-core-dropdown id="coreDropdown" class="core-dropdown" position="bottomRight">
          <div id="dropdown" class="layout horizontal">
            <div class="ranges">
              <div class="range-item" on-click="_rangeItemClicked" value="today">{{T("Today")}}</div>
              <div class="range-item" on-click="_rangeItemClicked" value="yesterday">{{T("Yesterday")}}</div>
              <div class="range-item" on-click="_rangeItemClicked" value="last7days">{{T("Last 7 Days")}}</div>
              <div class="range-item" on-click="_rangeItemClicked" value="last30days">{{T("Last 30 Days")}}</div>
              <div class="range-item" on-click="_rangeItemClicked" value="thisMonth">{{T("This Month")}}</div>
              <div class="range-item" on-click="_rangeItemClicked" value="lastMonth">{{T("Last Month")}}</div>
              <div class="range-item" on-click="_rangeItemClicked" value="custom">{{T("Custom")}}</div>
            </div>
            <div id="calendarStart" class="at-carbon-picker-container hidden">
              <at-carbon-date-picker id="startDatePicker" mode="start-range" format="[[_valueFormat]]"></at-carbon-date-picker>
            </div>
            <div id="calendarEnd" class="at-carbon-picker-container hidden">
              <at-carbon-date-picker id="endDatePicker" mode="end-range" format="[[_valueFormat]]"></at-carbon-date-picker>
            </div>
          </div>
        </at-core-dropdown>
      </div>
      <div id="hint"></div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'at-form-daterange',
    behaviors: [Tangere.behaviors.i18n, Tangere.behaviors.formUIGeneric, Tangere.behaviors.AtFormDaterangeInputValidation],
    properties: {
      label: {
        type: String,
        value: '',
        title: 'Label'
      },

      hideLabel: {
        type: Boolean,
        value: false,
        observer: '_hideLabelChanged',
        title: 'Do not show the label'
      },

      disabled: {
        type: Boolean,
        value: false,
        observer: '_disabledChanged',
        title: 'Field value can not be changed'
      },

      /**
       * Hides the element. When hidden nothing is displayed for the element
       * @property hide
       * @type Boolean
       * @default false
       */
      hide: {
        type: Boolean,
        value: false,
        observer: '_hideChanged',
        title: 'Field is invisible'
      },

      required: {
        type: Boolean,
        value: false,
        title: 'Input required'
      },

      format: {
        type: String,
        value: '',
        observer: '_formatChanged',
        title: 'Format'
      },

      startDate: {
        type: String,
        value: '',
        title: 'Start Date'
      },

      endDate: {
        type: String,
        value: '',
        title: 'End Date'
      },

      value: {
        type: String,
        observer: '_valueChanged',
        value: '',
        title: 'Value'
      }
    },

    observers: [
      '_updateDaterangeFromStartAndEndDate(startDate, endDate)',
      '_internalValidStateUpdate(required, startDate, endDate)'
    ],

    $meta: [{
      title: "Daterange",
      type: "daterange",
      events: ["value-changed"]
    }],

    _hideLabelChanged: function(newValue, oldValue) {
      var label = this.$.label;
      this.toggleClass("hidden", newValue, label);
    },

    ready: function() {
      var self = this;
      var coreDropdown = this.$.coreDropdown;

      this._boundResizeHandler = function() {};
      this.orientation = 'horizontal';
      var dropdown = this.$.dropdown;
      var coreDropdown = this.$.coreDropdown;
      this.toggleClass('horizontal', this.orientation === 'horizontal', dropdown);
      this.toggleClass('vertical', this.orientation === 'vertical', dropdown);
      var contentContainer = this.$.contentContainer;
      var resizeUnboundHandler = function(event) {
        var windowWidth = contentContainer.getBoundingClientRect().width;
        var dropdownWidth = dropdown.getBoundingClientRect().width;
        var dropdownLeft = dropdown.getBoundingClientRect().left;
        if (self.orientation === 'horizontal') {
          if (dropdownWidth > windowWidth) {
            self.toggleClass('horizontal', false, dropdown);
            self.toggleClass('vertical', true, dropdown);
            self.orientation = 'vertical';
          } else {
            self.toggleClass('horizontal', true, dropdown);
            self.toggleClass('vertical', false, dropdown);
          }
        } else if (self.orientation === 'vertical') {
          if (dropdownWidth * 3 > windowWidth) {
            self.toggleClass('horizontal', false, dropdown);
            self.toggleClass('vertical', true, dropdown);
          } else {
            self.toggleClass('horizontal', true, dropdown);
            self.toggleClass('vertical', false, dropdown);
            self.orientation = 'horizontal';
          }
        }
        if (coreDropdown.isOpen()) {
          coreDropdown.hide();
          coreDropdown.show();
        }
      }

      var boundResizeHandler = resizeUnboundHandler.bind(this);
      window.addEventListener('resize', boundResizeHandler);
      this._boundResizeHandler = boundResizeHandler;

      var startDatePicker = this.$.startDatePicker;
      var endDatePicker = this.$.endDatePicker;
      startDatePicker.addEventListener('start-date-changed', function(event) {
        if (self._isInternalUpdateValue) {
          return;
        }
        self._isInternalUpdateValue = true;
        var startDateValue = event.detail.value;
        self._updateDaterangeFromDatePickers(startDateValue, self.endDate);
        self._isInternalUpdateValue = false;
      });

      endDatePicker.addEventListener('end-date-changed', function(event) {
        if (self._isInternalUpdateValue) {
          return;
        }
        self._isInternalUpdateValue = true;
        var endDateValue = event.detail.value;
        self._updateDaterangeFromDatePickers(self.startDate, endDateValue);
        self._isInternalUpdateValue = false;
      });

      this._valueFormat = "YYYY-MM-DD",
      this._isReady = true;
      this._displayFormat = this._localizedFormat("date");
      this._internalValidStateUpdate(this.required, this.startDate, this.endDate);

      // Handle setting initial values
      function isString(obj) {
        return Object.prototype.toString.call(obj) === "[object String]";
      }
      var value = this.value;
      var startDate = this.startDate;
      var endDate = this.endDate;
      if (value === null || (isString(value) && value.length > 0)) {

        // If value is set, split value into startDate and endDate and update startDate, endDate, _displayValue and date pickers
        // we accept null, and value.length > 0 filters initial value of ""
        // name of the function is _valueChanged on purpose because it follows polymer-js naming convention(s)
        this._valueChanged(value);
      } else if (
        (isString(startDate) && startDate.length > 0) ||
        (isString(endDate) && endDate.length > 0)
      ) {

        // If value is not set, check if startDate and endDate are set and update value, _displayValue and date pickers
        // we do not accept null; startDate and endDate must be non empty strings
        this._updateDaterangeFromStartAndEndDate(startDate, endDate);
      } else {
        // else set everything to initial values
        this._valueChanged(this.properties.value.value);
      }
    },

    _disabledChanged: function(newValue, oldValue) {
      var triggerRange = this.$.triggerRange;
      this.toggleAttribute('disabled', newValue, triggerRange);
      var triggerRangeIcon = this.$.triggerRangeIcon;
      this.toggleAttribute('disabled', newValue, triggerRangeIcon);
      var atContainer = this.$.atContainer;
      this.toggleClass('disabled', newValue, atContainer);
    },

    _hideChanged: function(newValue, oldValue) {
      var wrapper = this.$.atContainer;
      this.toggleClass('hidden', newValue, wrapper);
    },

    _internalValidStateUpdate: function(required, startDate, endDate) {
      if (this._isReady) {
        this.validate();
      }
    },

    _formatChanged: function(newValue, oldValue) {
      function isString(obj) {
        return Object.prototype.toString.call(obj) === "[object String]";
      }
      var format = newValue;
      if (!isString(format) || format === "") {
        return;
      }

      if (!this._containsChars(['Y', 'M', 'D'], format) || this._containsChars(['h', 'm', 's'], format)) {
        // set format to the default format for date
        format = this._localizedFormat("date");
        // log the error
        console.log('Value ' + newValue + ' is not a valid format for date. Using default, ' + format + ', format instead.');
      }
      this._displayFormat = format;
      this.format = format;
      this.fire('format-changed', {
        value: format
      });

      /*
       * reformat display value to new format
       */
      var startDateMoment = moment(this.startDate, this._valueFormat, true);
      var endDateMoment = moment(this.endDate, this._valueFormat, true);
      this._updateDisplayValue(startDateMoment, endDateMoment, this._displayFormat, this.$.triggerRange);
    },
    /**
     * checks if source contains any of the chars
     * @param {Array} chars
     * @param {String} source
     */
    _containsChars: function(chars, source) {
      var result = false;
      chars.forEach(function(char, index) {
        result = result || source.indexOf(char) !== -1;
      });
      return result;
    },

    validate: function(showError) {
      if (showError === undefined) {
        showError = this.autoValidate;
      }

      var validationResult = this._validateBaseData();
      if (showError) {
        this._handleValidationResult(validationResult);
      }
      if (!validationResult.isValid) {
        return validationResult.isValid;
      }

      validationResult = this._validateData(this, this.value, this.T.bind(this));
      if (showError) {
        this._handleValidationResult(validationResult);
      }

      return validationResult.isValid;
    },

    _updateUIValidState: function(isValid) {
      var label = this.$.label;
      this.toggleClass('error', !isValid, label);
      var contentContainer = this.$.contentContainer;
      this.toggleClass('error', !isValid, contentContainer);
    },

    /*
      Flow 1. value is set as attribute or property
        * .value will be split into start date and end date
        * .startDate and .endDate will be set from .value parts and formatted according to _valueFormat
        * _displayValue will be updated and formatted according to _displayFormat
        * dropdown will  be updated, "custom" will be selected and startDate and endDate will be set on datepickers
        * in case of invalid values correct validation messages will be displayed

        * any feedback will  be blocked:
          * setting .startDate/.endDate will not cause recalculation of .value
          * setting _displayValue will not cause recalculation of .value
          * updating datepikcers will not cause recalculation of .value
    */
    _valueChanged: function (newValue, oldValue) {
      function isString(obj) {
        return Object.prototype.toString.call(obj) === "[object String]";
      }
      // !this._isReady ignore initial polymer-js initialization
      // we manually initialize from ready function
      // this._isInternalUpdateValue to block feedback
      if (!this._isReady || this._isInternalUpdateValue) {
        return;
      }
      this._isInternalUpdateValue = true;

      if (newValue === null) {
        // update display value to empty string
        this.$.triggerRange.value = "";

        // update datepickers to ... what?
        this.$.startDatePicker.startDate = "";
        this.$.startDatePicker.endDate = "";

        this.$.endDatePicker.startDate = "";
        this.$.endDatePicker.endDate = "";
        // clear selection from dropdown
        this._selectedChanged("");

        // update startDate and endDate to null
        this.startDate = null;
        this._fireStartDateChangedEvent(startDateStr);
        this.endDate = null;
        this._fireEndDateChangedEvent(endDateStr);
      } else if (isString(newValue) && newValue.length > 0 && (newValue.match(/\s/g)||[]).length == 2) {
        // if newValue is a nonempty string with two space characters
        // se expect newValue to be _valueFormat to _valueFormat
        // after split there are three parts
        // if there are more or less newValue is invalid
        var valueParts = newValue.split(" ");

        var startDateStr = valueParts[0];
        var endDateStr = valueParts[2];
        var startDateMoment = moment(startDateStr, this._valueFormat, true);
        var endDateMoment = moment(endDateStr, this._valueFormat, true);
        if (startDateMoment.isValid() && endDateMoment.isValid()) {
          // update display value
          this._updateDisplayValue(startDateMoment, endDateMoment, this._displayFormat, this.$.triggerRange);
          // update datepickers
          this.$.startDatePicker.startDate = startDateStr;
          this.$.startDatePicker.endDate = endDateStr;
          this.$.endDatePicker.startDate = startDateStr;
          this.$.endDatePicker.endDate = endDateStr;
        } else {
          this.$.triggerRange.value = newValue;
          this.$.startDatePicker.startDate = "";
          this.$.startDatePicker.endDate = "";
          this.$.endDatePicker.startDate = "";
          this.$.endDatePicker.endDate = "";
        }

        this.startDate = startDateStr;
        this._fireStartDateChangedEvent(startDateStr);
        this.endDate = endDateStr;
        this._fireEndDateChangedEvent(endDateStr);

      } else {
        // string is invalid
        // update startDate and endDate
        this.startDate = "";
        this.endDate = "";
        // update display value
        this.$.triggerRange.value = String(newValue);
        // update datepickers
        this.$.startDatePicker.startDate = "";
        this.$.startDatePicker.endDate = "";
        this.$.endDatePicker.startDate = "";
        this.$.endDatePicker.endDate = "";
      }

      this._fireValueChangedEvent(newValue);
      this._isInternalUpdateValue = false;
    },

    // compute value computes the value from startDate and endDate
    _updateDaterangeFromStartAndEndDate: function(startDate, endDate) {
      function isString(obj) {
        return Object.prototype.toString.call(obj) === "[object String]";
      }
      function isEmptyString(obj) {
        return Object.prototype.toString.call(obj) === "[object String]" && obj.length === 0;
      }

      if (!this._isReady || this._isInternalUpdateValue) {
        return;
      }
      this._isInternalUpdateValue = true;

      var result = '';

      if (isString(startDate) && isString(endDate) && startDate !== "" && endDate !== "") {
        this._fireStartDateChangedEvent(startDate);
        this._fireEndDateChangedEvent(endDate);

        var startDateMoment = moment(startDate, this._valueFormat, true);
        var endDateMoment = moment(endDate, this._valueFormat, true);

        var startDateValid = startDateMoment.isValid();
        var endDateValid = endDateMoment.isValid()

        if (startDateValid && endDateValid) {
          // update display value
          this._updateDisplayValue(startDateMoment, endDateMoment, this._displayFormat, this.$.triggerRange);

          // update date pickers
          this.$.startDatePicker.startDate = startDate;
          this.$.startDatePicker.endDate = endDate;
          this.$.endDatePicker.startDate = startDate;
          this.$.endDatePicker.endDate = endDate;

          this._selectedChanged("custom");

          // update output value
          var outputValue = this.T("{0} to {1}", startDate, endDate);
          if (this.value !== outputValue) {
            this.value = outputValue;
            this._fireValueChangedEvent(outputValue);
          }
        } else {
          // update display value
          this.$.triggerRange.value = this.T("{0} to {1}", startDate, endDate);

          // update date pickers
          this.$.startDatePicker.startDate = "";
          this.$.startDatePicker.endDate = "";
          this.$.endDatePicker.startDate = "";
          this.$.endDatePicker.endDate = "";

          this._selectedChanged("");

          // update output value
          var outputValue = this.T("{0} to {1}", startDate, endDate);
          if (this.value !== outputValue) {
            this.value = outputValue;
            this._fireValueChangedEvent(outputValue);
          }
        }
      } else if (startDate === "" || endDate === "") {
        this._fireStartDateChangedEvent(startDate);
        this._fireEndDateChangedEvent(endDate);

        // update display value
        this.$.triggerRange.value = "";

        // update datepickers
        this.$.startDatePicker.startDate = "";
        this.$.startDatePicker.endDate = "";
        this.$.endDatePicker.startDate = "";
        this.$.endDatePicker.endDate = "";

        this._selectedChanged("");

        // update output value
        var outputValue = this.T("{0} to {1}", startDate, endDate);
        if (this.value !== outputValue) {
          this.value = outputValue;
          this._fireValueChangedEvent(outputValue);
        }
      } else {
        this._fireStartDateChangedEvent(startDate);
        this._fireEndDateChangedEvent(endDate);

        // start date and end date are not strings
        var startDateStr = String(startDate);
        var endDateStr = String(endDate);

        // update display value
        this.$.triggerRange.value = this.T("{0} to {1}", startDateStr, endDateStr);

        // update datepickers
        this.$.startDatePicker.startDate = "";
        this.$.startDatePicker.endDate = "";
        this.$.endDatePicker.startDate = "";
        this.$.endDatePicker.endDate = "";

        this._selectedChanged("");

        // update output value
        var outputValue = this.T("{0} to {1}", startDateStr, endDateStr);
        if (this.value !== outputValue) {
          this.value = outputValue;
          this._fireValueChangedEvent(outputValue);
        }
      }

      this._isInternalUpdateValue = false;
    },

    _updateDaterangeFromDatePickers: function(startDate, endDate) {
      if (!this._isReady || this._isUpdateDaterangeFromDatePickers) {
        return;
      }
      this._isUpdateDaterangeFromDatePickers = true;

      // startDate and endDate should already be in _valueFormat
      var startDateMoment = moment(startDate, this._valueFormat, true);
      var endDateMoment = moment(endDate, this._valueFormat, true);

      // update startDate and endDate
      this.startDate = startDate;
      this._fireStartDateChangedEvent(startDate);
      this.endDate = endDate;
      this._fireEndDateChangedEvent(endDate);

      if (startDateMoment.isValid() && endDateMoment.isValid()) {
        // update display value
        this._updateDisplayValue(startDateMoment, endDateMoment, this._displayFormat, this.$.triggerRange);
      } else {
        // update display value
        this.$.triggerRange.value = this.T("{0} to {1}", startDate, endDate);
      }

      // update output value
      var outputValue = this.T("{0} to {1}", startDate, endDate);
      this.value = outputValue;
      this._fireValueChangedEvent(outputValue);

      this._isUpdateDaterangeFromDatePickers = false;
    },

    _updateDisplayValue: function (startDateMoment, endDateMoment, displayFormat, input) {
      var startDateDisplayStr = startDateMoment.format(displayFormat);
      var endDateDisplayStr = endDateMoment.format(displayFormat);
      var displayResult = this.T("{0} to {1}", startDateDisplayStr, endDateDisplayStr);

      input.value = displayResult;
    },

    _rangeItemClicked: function(event) {
      var value = event.target.getAttribute('value');
      this.$.coreDropdown.hide();
      this._selectedChanged(value);
    },

    _selectedChanged: function(newValue) {
      var activeItem = this.$$('.range-item.active');
      if (activeItem) {
        Polymer.dom(activeItem).classList.remove('active');
      }

      if (newValue === "") {
        return;
      }

      var calendarStart = this.$.calendarStart;
      this.toggleClass('hidden', newValue !== 'custom', calendarStart);
      var calendarEnd = this.$.calendarEnd;
      this.toggleClass('hidden', newValue !== 'custom', calendarEnd);
      if (this._boundResizeHandler !== undefined) {
        this._boundResizeHandler();
      }
      if (newValue === 'custom') {
        this.$.coreDropdown.show();
      }
      this._isInternalUpdate = true;
      var newStartDate;
      var newEndDate;
      switch (newValue) {
        case 'today':
          newStartDate = this._formatDate(moment());
          newEndDate = this._formatDate(moment());
          break;
        case 'yesterday':
          newStartDate = this._formatDate(moment().subtract(1, "days"));
          newEndDate = this._formatDate(moment().subtract(1, "days"));
          break;
        case 'last7days':
          newStartDate = this._formatDate(moment().subtract(6, "days"));
          newEndDate = this._formatDate(moment());
          break;
        case 'last30days':
          newStartDate = this._formatDate(moment().subtract(30, "days"));
          newEndDate = this._formatDate(moment());
          break;
        case 'thisMonth':
          newStartDate = this._formatDate(moment().startOf("month"));
          newEndDate = this._formatDate(moment().endOf("month"));
          break;
        case 'lastMonth':
          newStartDate = this._formatDate(moment().subtract(1, "months").startOf("month"));
          newEndDate = this._formatDate(moment().subtract(1, "months").endOf("month"));
          break;
        case 'custom':
          // for initialization purposes (first time) startDate and endDate are set to today
          // subject to change
          if (this.startDate === '') {
            newStartDate = this._formatDate(moment());
          }
          if (this.endDate === '') {
            newEndDate = this._formatDate(moment());
          }
          break;
      }
      this._isInternalUpdate = false;
      if (newValue) {
        var liElem = this.$$('.range-item[value=' + newValue + ']');
        if (liElem) {
          Polymer.dom(liElem).classList.add('active');
        }
      }
      if (newStartDate !== undefined) {
        this.startDate = newStartDate;
        this._fireStartDateChangedEvent(newStartDate);
      }
      if (newEndDate !== undefined) {
        this.endDate = newEndDate;
        this._fireEndDateChangedEvent(newEndDate);
      }
    },

    _formatDate: function(moment) {
      if (!this.format) {
        // this.format = this._internalFormat;
      }
      return moment.format(this._internalFormat);
    },

    _triggerRangeMouseDown: function(event) {
      if (!this.disabled) {
        this._boundResizeHandler();
        this.$.coreDropdown.toggle(this.$.triggerRangeIcon);
      }
    },

    _iconButtonMouseDown: function(event) {
      if (!this.disabled) {
        this._boundResizeHandler();
        this.$.coreDropdown.toggle(this.$.triggerRangeIcon);
      }
    },

    // *ij* the main purpose of this function is to validate startDate and endDate format when they are programmatically set
    _validateValueFormat: function(value) {
      var result = true;
      var valueParts = value.split(' to ');
      var startDate = valueParts[0];
      var endDate = valueParts[1];
      var dateFormat = this._internalFormat;

      var startDateValid = true;
      var endDateValid = true;

      if (value === '') {
        return true;
      }

      if (startDate !== undefined && startDate !== '') {
        startDateValid = moment(startDate, dateFormat).isValid();
      }

      if (endDate !== undefined && endDate !== '') {
        endDateValid = moment(endDate, dateFormat).isValid();
      }

      result = result && startDateValid && endDateValid;

      if (!startDateValid) {
        this._errorMessage = this.T('Start date is in invalid format. Enter start date in format {0}', dateFormat);
      } else if (!endDateValid) {
        this._errorMessage = this.T('End date is in invalid format. Enter end date in format {0}', dateFormat);
      }

      return result;
    },

    _fireStartDateChangedEvent: function(newValue) {
      this.fire('start-date-changed', {
        value: newValue
      }, {
        bubbles: false
      });
    },

    _fireEndDateChangedEvent: function(newValue) {
      this.fire('end-date-changed', {
        value: newValue
      }, {
        bubbles: false
      });
    },

    open: function(evnet) {
      if (!this.disabled) {
        this._boundResizeHandler();
        this.$.coreDropdown.open();
      }
    },

    close: function(event) {
      this.$.coreDropdown.close();
    },

    focus: function() {
      var trigger = this.$.triggerRange;
      trigger.focus();
    },

    _getFocusableElement: function() {
      var focusable = this.$.triggerRange;
      return focusable;
    }
  });
</script>
