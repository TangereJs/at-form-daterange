<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="../at-form-behaviors/at-form-behaviors.html">
<link rel="import" href="../at-carbon-icon-button/at-carbon-icon-button.html">
<link rel="import" href="../at-core-dropdown/at-core-dropdown.html">
<link rel="import" href="../at-carbon-date-picker/at-carbon-date-picker.html">
<link rel="import" href="../at-carbon-moment/at-carbon-moment.html">
<link rel="import" href="../iron-label/iron-label.html">
<link rel="import" href="at-form-daterange-input-validation-behavior.html">

<dom-module id="at-form-daterange">
  <template>
    <style include="at-form-common"></style>
    <style>
      :host * {
        box-sizing: border-box;
      }

      :host {
        @apply --at-form-host;
      }

      #triggerContainer {
        @apply --layout-horizontal;
      }

      .icon-background {
        color: var(--at-form-daterange-icon-text-color);
        width: 32px;
        height: 32px;
      }

      .dropdown-container {
        position: relative;
        display: block;
      }

      .ranges {
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        padding: 4px 8px;
        margin: 4px;
        min-width: 175px;
        min-height: 256px;
      }

      .ranges.hidden {
        display: none;
      }

      .ranges .range-item {
        padding: 4px 8px;
        margin: 2px 0;
        cursor: pointer;
        border-radius: 5px;
        @apply --at-form-label-font;
        @apply --at-text-selected;
      }

      .ranges .range-item.active,
      .ranges .range-item:hover {
        @apply --at-text-primary-selected;
      }

      .custom-range {
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        padding: 4px 8px;
        margin: 4px;
        min-width: 175px;
        min-height: 256px;
      }

      .custom-range.hidden {
        display: none;
      }

      .custom-range .custom-range-item {
        padding: 4px 8px;
        margin: 2px 0;
        cursor: pointer;
        border-radius: 5px;
        flex: 3;
        @apply --at-form-label-font;
        @apply --at-text-selected;
        display: flex;
        justify-content: center;
        flex-direction: column;
        text-align: center;
      }

      .custom-range .custom-range-item.active,
      .custom-range .custom-range-item:hover {
        @apply --at-text-primary-selected;
      }

      .picker-header {
        text-align: center;
        position: relative;
        line-height: 40px;
      }

      .picker-header .confirm-icon {
        position: absolute;
        right: 0;
        top: 0;
      }

      .picker-header-hr {
        margin: 0 4px;
        opacity: 0.5;
      }
    </style>
    <div id="atContainer" class="at-container">
      <iron-label id="label" for="triggerRange">{{label}}</iron-label>
      <div id="contentContainer" class="at-content-container">
        <div id="triggerContainer" class="input-group">
          <input id="triggerRange" class="at-content has-placeholder date">
          <at-carbon-icon-button id="triggerRangeIcon" class="icon-background input-group-addon" icon="now:calendar"></at-carbon-icon-button>
        </div>
      </div>
      <div id="hint"></div>
    </div>
    <at-core-dropdown id="coreDropdown" class="core-dropdown" position="bottomRight" y-offset="2">
      <div id="dropdown" class="">
        <div id="ranges" class="ranges">
          <div class="range-item" on-tap="_rangeItemClicked" value="today">{{T("Today")}}</div>
          <div class="range-item" on-tap="_rangeItemClicked" value="yesterday">{{T("Yesterday")}}</div>
          <div class="range-item" on-tap="_rangeItemClicked" value="last7days">{{T("Last 7 Days")}}</div>
          <div class="range-item" on-tap="_rangeItemClicked" value="last30days">{{T("Last 30 Days")}}</div>
          <div class="range-item" on-tap="_rangeItemClicked" value="thisMonth">{{T("This Month")}}</div>
          <div class="range-item" on-tap="_rangeItemClicked" value="lastMonth">{{T("Last Month")}}</div>
          <div class="range-item" on-tap="_rangeItemClicked" value="custom">{{T("Custom")}}</div>
        </div>
        <div id="customRangeSelection" class="custom-range hidden">
          <div class="custom-range-item" on-tap="_customRangeItemClicked" value="back">{{T("Custom")}}</div>
          <div class="custom-range-item" on-tap="_customRangeItemClicked" value="startDate">
            <span>{{T("Start")}}:</span>
            <span id="startDateValue"></span>
          </div>
          <div class="custom-range-item" on-tap="_customRangeItemClicked" value="endDate">
            <span>{{T("End")}}:</span>
            <span id="endDateValue"></span>
          </div>
        </div>
        <div id="calendarStart" class="at-carbon-picker-container hidden">
          <div class="picker-header">Select start date
            <at-carbon-icon-button class="confirm-icon" on-tap="_datepickerOnTap" icon="now:checkmark"></at-carbon-icon-button>
          </div>
          <hr class="picker-header-hr" />
          <at-carbon-date-picker id="startDatePicker" mode="start-range"></at-carbon-date-picker>
        </div>
        <div id="calendarEnd" class="at-carbon-picker-container hidden">
          <div class="picker-header">Select end date
            <at-carbon-icon-button class="confirm-icon" on-tap="_datepickerOnTap" icon="now:checkmark"></at-carbon-icon-button>
          </div>
          <hr class="picker-header-hr" />
          <at-carbon-date-picker id="endDatePicker" mode="end-range"></at-carbon-date-picker>
        </div>
      </div>
    </at-core-dropdown>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'at-form-daterange',
    behaviors: [Tangere.behaviors.i18n, Tangere.behaviors.formUIGeneric, Tangere.behaviors.AtFormDaterangeInputValidation],
    properties: {
      label: {
        type: String,
        value: '',
        title: 'Label'
      },

      hideLabel: {
        type: Boolean,
        value: false,
        observer: '_hideLabelChanged',
        title: 'Do not show the label'
      },

      disabled: {
        type: Boolean,
        value: false,
        observer: '_disabledChanged',
        title: 'Field value can not be changed'
      },

      /**
       * Hides the element. When hidden nothing is displayed for the element
       * @property hide
       * @type Boolean
       * @default false
       */
      hide: {
        type: Boolean,
        value: false,
        observer: '_hideChanged',
        title: 'Field is invisible'
      },

      required: {
        type: Boolean,
        value: false,
        title: 'Input required'
      },

      format: {
        type: String,
        value: '',
        observer: '_formatChanged',
        title: 'Format'
      },

      startDate: {
        type: String,
        value: '',
        title: 'Start Date'
      },

      endDate: {
        type: String,
        value: '',
        title: 'End Date'
      },

      value: {
        type: String,
        observer: '_valueChanged',
        value: '',
        title: 'Value'
      }
    },

    listeners: {
      'triggerRangeIcon.keydown': '_host_onKeydown',
      'triggerRangeIcon.tap': '_iconButtonMouseDown'
    },

    observers: [
      '_updateDaterangeFromStartAndEndDate(startDate, endDate)',
      '_internalValidStateUpdate(required, startDate, endDate)'
    ],

    $meta: [{
      title: "Daterange",
      type: "daterange",
      events: ["value-changed"],
      icon: "now:calendar"
    }],

    _keyCodes: {
      ESC: 27
    },

    get _valueFormat() {
      return "YYYY-MM-DD";
    },

    get _displayFormat() {
      if (!this.__displayFormat__) {
        this.__displayFormat__ = this._localizedFormat("date");
      }
      return this.__displayFormat__;
    },

    set _displayFormat(value) {
      this.__displayFormat__ = value;
    },

    _emptyFn: function() { },

    _host_onKeydown: function(event) {
      var keyCodes = this._keyCodes;
      var keyCode = event.which;
      var coreDropdown = this.$.coreDropdown;

      switch (keyCode) {
        case keyCodes.ESC:
          coreDropdown.hide();
          break;
        default:
          break;
      }
    },

    _iconButtonMouseDown: function(event) {
      this._toggleCoreDropdown(event);
    },

    _hideLabelChanged: function(newValue, oldValue) {
      var label = this.$.label;
      this.toggleClass("hidden", newValue, label);
    },

    ready: function() {
      var self = this;
      var coreDropdown = this.$.coreDropdown;

      this._boundResizeHandler = function() { };
      this.orientation = 'horizontal';
      var dropdown = this.$.dropdown;
      var coreDropdown = this.$.coreDropdown;
      this.toggleClass('horizontal', this.orientation === 'horizontal', dropdown);
      this.toggleClass('vertical', this.orientation === 'vertical', dropdown);
      var contentContainer = this.$.contentContainer;
      var resizeUnboundHandler = function(event) {
        var windowWidth = contentContainer.getBoundingClientRect().width;
        var dropdownWidth = dropdown.getBoundingClientRect().width;
        var dropdownLeft = dropdown.getBoundingClientRect().left;
        if (self.orientation === 'horizontal') {
          if (dropdownWidth > windowWidth) {
            self.toggleClass('horizontal', false, dropdown);
            self.toggleClass('vertical', true, dropdown);
            self.orientation = 'vertical';
          } else {
            self.toggleClass('horizontal', true, dropdown);
            self.toggleClass('vertical', false, dropdown);
          }
        } else if (self.orientation === 'vertical') {
          if (dropdownWidth * 3 > windowWidth) {
            self.toggleClass('horizontal', false, dropdown);
            self.toggleClass('vertical', true, dropdown);
          } else {
            self.toggleClass('horizontal', true, dropdown);
            self.toggleClass('vertical', false, dropdown);
            self.orientation = 'horizontal';
          }
        }

        // @DOC What is going on here?
        // 1. at-core-dropdown: on attached it moves its internal dropdown-impl to document.body
        // 2. when resizeUnboundHandler (see above) updates layout that causes polymer-mini.MutationObserver.observe.characterData function to reattach dropdowm-impl to core-dropdown
        // 3. polymer-mini.MutationObserver.observe.characterData function is executed in a debounce way as microtask
        // 4. we need to reattach dropdown-impl to document.body so we call _returnImplToDocumentBody
        // 5. we need to do this as async becuase microtask from 3. needs to complete first
        self.async(function() {
          coreDropdown._returnImplToDocumentBody();
        });
      }

      var boundResizeHandler = resizeUnboundHandler.bind(this);
      window.addEventListener('resize', boundResizeHandler);
      this._boundResizeHandler = boundResizeHandler;

      var startDatePicker = this.$.startDatePicker;
      var endDatePicker = this.$.endDatePicker;

      startDatePicker.addEventListener('start-date-changed', this._startDatePickerStartDateChangedEventHandler.bind(this));
      endDatePicker.addEventListener('end-date-changed', this._endDatePickerEndDateChangedEventHandler.bind(this));

      this.$.triggerRange.addEventListener('change', function(event) {
        var value = event.target.value;
        self._updateDaterangeFromUserInput(value);
        self.validate();
      });

      this.$.triggerRange.addEventListener('blur', function(event) {
        self.validate();
      });

      this._isReady = true;

      // Handle setting initial values
      var value = this.value;
      var startDate = this.startDate;
      var endDate = this.endDate;
      if (value === null || (this._isString(value) && value.length > 0)) {

        // If value is set, split value into startDate and endDate and update startDate, endDate, _displayValue and date pickers
        // we accept null, and value.length > 0 filters initial value of ""
        // name of the function is _valueChanged on purpose because it follows polymer-js naming convention(s)
        this._valueChangedImpl(value);
      } else if (
        (this._isString(startDate) && startDate.length > 0) ||
        (this._isString(endDate) && endDate.length > 0)
      ) {
        // If value is not set, check if startDate and endDate are set and update value, _displayValue and date pickers
        // we do not accept null; startDate and endDate must be non empty strings
        this._updateDaterangeFromStartAndEndDateImpl(startDate, endDate);

      } else {
        // else set everything to initial values
        this._valueChangedImpl(this.properties.value.value);
      }

      this._internalValidStateUpdate(this.required, this.startDate, this.endDate);

      this._attachValueChangedHandler();
      this._attachUpdateDaterangeFromStartAndEndDateHandler();
      this._attachUpdateDaterangeFromUserInputOnValidateHandler();
    },

    _disabledChanged: function(newValue, oldValue) {
      var triggerRange = this.$.triggerRange;
      this.toggleAttribute('disabled', newValue, triggerRange);
      var triggerRangeIcon = this.$.triggerRangeIcon;
      this.toggleAttribute('disabled', newValue, triggerRangeIcon);
      var atContainer = this.$.atContainer;
      this.toggleClass('disabled', newValue, atContainer);
    },

    _hideChanged: function(newValue, oldValue) {
      var wrapper = this.$.atContainer;
      this.toggleClass('hidden', newValue, wrapper);
    },

    _internalValidStateUpdate: function(required, startDate, endDate) {
      this._internalValidStateUpdateImpl(required, startDate, endDate);
    },

    _attachInternalValidStateUpdateHandler: function() {
      this._internalValidStateUpdate = this._internalValidStateUpdateImpl;
    },

    _detachInternalValidStateUpdateHandler: function() {
      this._internalValidStateUpdate = this._emptyFn;
    },

    _internalValidStateUpdateImpl: function(required, startDate, endDate) {
      if (!this._isReady) return;

      if (this._showErrorsWhenAttached) {
        this._showErrorsWhenAttached = undefined;
        this._detachUpdateDaterangeFromUserInputOnValidateHandler();
        this.validate(true);
        this._attachUpdateDaterangeFromUserInputOnValidateHandler();
        return;
      
      } else if (this._clearErrorsWhenAttached) {
        this._clearErrorsWhenAttached = undefined;
        this._detachUpdateDaterangeFromUserInputOnValidateHandler();
        this.validate(false);
        this._attachUpdateDaterangeFromUserInputOnValidateHandler();
        return;
      }

      this._detachUpdateDaterangeFromUserInputOnValidateHandler();
      this.validate();
      this._attachUpdateDaterangeFromUserInputOnValidateHandler();
    },

    _formatChanged: function(newValue, oldValue) {
      var format = newValue;
      if (!this._isString(format) || format === "") {
        return;
      }

      if (!this._containsChars(['Y', 'M', 'D'], format) || this._containsChars(['h', 'm', 's'], format)) {
        // set format to the default format for date
        format = this._localizedFormat("date");
        // log the error
        console.log('Value ' + newValue + ' is not a valid format for date. Using default, ' + format + ', format instead.');
      }
      this._displayFormat = format;
      this.format = format;
      this.fire('format-changed', {
        value: format
      });

      /*
       * reformat display value to new format
       */
      var startDateMoment = moment(this.startDate, this._valueFormat, true);
      var endDateMoment = moment(this.endDate, this._valueFormat, true);
      this._updateDisplayValue(startDateMoment, endDateMoment, this._displayFormat, this.$.triggerRange);
    },
    /**
     * checks if source contains any of the chars
     * @param {Array} chars
     * @param {String} source
     */
    _containsChars: function(chars, source) {
      var result = false;
      chars.forEach(function(char, index) {
        result = result || source.indexOf(char) !== -1;
      });
      return result;
    },

    validate: function(showError) {
      if (!this.$ && this.autoValidate == false && showError == true) {
        // showError should be true when _internalValidStateUpdate is called from ready after element is attached
        this._showErrorsWhenAttached = true;
      
      } else if (!this.$ && this.autoValidate == true && showError == false) {
        this._clearErrorsWhenAttached = true;
      }

      if (showError === undefined) { showError = this.autoValidate; }

      var inputValue = this.$ ? this.$.triggerRange.value : this.value;
      if ((this.value === null && inputValue !== "") || (this.value !== null && this.value !== inputValue)) {
        this._updateDaterangeFromUserInputOnValidate(inputValue);
      }

      var validationResult = this._validateBaseData();
      this._handleValidationResult(validationResult);
      if (!validationResult.isValid) {
        return validationResult.isValid;
      }

      // validate user input
      // newValue is user input
      var newValue = this.$ ? this.$.triggerRange.value : this.value;
      var trimmedNewvalue = newValue.trim();
      if (["null", null, ""].indexOf(trimmedNewvalue) === -1) {

        var validMoments = this._getValidMomentObjectsFromUserInputString(trimmedNewvalue);

        if (validMoments.length !== 2) {
          validationResult = {
            isValid: false,
            errorMessage: this.T("Input string {0} is not valid", newValue)
          };
        }

        if (showError) {
          this._handleValidationResult(validationResult);
        }

        if (!validationResult.isValid) {
          return validationResult.isValid;
        }
      }

      // Polymer 2.x
      // validate startDate and endDate before element is attached to the DOM when value is not set
      if (!this.$ && this._isString(this.value) && this.value.length == 0) {
        var startDateMoment = moment(this.startDate);
        var isStartDateValid = startDateMoment.isValid();
        var endDateMoment = moment(this.endDate);
        var isEndDateValid = startDateMoment.isValid();
        if (isStartDateValid && isEndDateValid && startDateMoment.isAfter(endDateMoment)) {
          validationResult.isValid = false;
          validationResult.errorMessage = this.T("Start date of {0} is after end date of {1}", startDateMoment.format(this._displayFormat), endDateMoment.format(this._displayFormat));
          if (showError) {
            this._handleValidationResult(validationResult);
          }
          return validationResult.isValid;
        }
      }

      validationResult = this._validateData(this, this.value, this.T.bind(this));
      if (showError) {
        this._handleValidationResult(validationResult);
      }

      return validationResult.isValid;
    },

    _updateUIValidState: function(isValid) {
      if (!this.$) return;

      var label = this.$.label;
      this.toggleClass('error', !isValid, label);
      var contentContainer = this.$.contentContainer;
      this.toggleClass('error', !isValid, contentContainer);
    },

    /*
      Flow 1. value is set as attribute or property
        * .value will be split into start date and end date
        * .startDate and .endDate will be set from .value parts and formatted according to _valueFormat
        * _displayValue will be updated and formatted according to _displayFormat
        * dropdown will  be updated, "custom" will be selected and startDate and endDate will be set on datepickers
        * in case of invalid values correct validation messages will be displayed

        * any feedback will  be blocked:
          * setting .startDate/.endDate will not cause recalculation of .value
          * setting _displayValue will not cause recalculation of .value
          * updating datepikcers will not cause recalculation of .value
    */
    _valueChanged: function() {
      // NOTE Flow 1 _valueChanged handler is initally emptyFn because initialization is done in ready function
      // and _valueChagned handler is attached in ready function
    },

    _attachValueChangedHandler: function() { this._valueChanged = this._valueChangedImpl; },
    _detachValueChangedHandler: function() { this._valueChanged = this._emptyFn; },

    _valueChangedImpl: function(newValue, oldValue) {
      var displayStartDateStr = '';
      var displayEndDateStr = '';
      var pickerStartDateStr = '';
      var pickerEndDateStr = '';
      var startDateStr = '';
      var endDateStr = '';

      if (this._isString(newValue) && newValue.length > 0 && newValue.indexOf("/") > -1) {
        // we expect newValue to be in ISO 8601 format <start-date>/<end-date>
        // in our case that is _valueFormat/_valueFormat
        var valueParts = newValue.split("/");

        var localizedFormat = this._localizedFormat("date");

        var startDateMoment = moment(valueParts[0], this._valueFormat, true);
        var endDateMoment = moment(valueParts[1], this._valueFormat, true);
        var startDateValid = startDateMoment.isValid();
        var endDateValid = endDateMoment.isValid();

        if (startDateValid) {
          displayStartDateStr = startDateMoment.format(this._displayFormat);
          pickerStartDateStr = startDateMoment.format(localizedFormat);
          startDateStr = startDateMoment.format(this._valueFormat);
        }

        if (endDateValid) {
          displayEndDateStr = endDateMoment.format(this._displayFormat);
          pickerEndDateStr = endDateMoment.format(localizedFormat);
          endDateStr = endDateMoment.format(this._valueFormat);
        }

      } else if (newValue === null) {
        startDateStr = null;
        endDateStr = null;
      }

      // set startDate and endDate properties
      this._detachUpdateDaterangeFromStartAndEndDateHandler();
      this._detachInternalValidStateUpdateHandler();

      this.startDate = startDateStr;
      this.endDate = endDateStr;

      this._attachInternalValidStateUpdateHandler();
      this._attachUpdateDaterangeFromStartAndEndDateHandler();

      // handle display value
      var displayValue = '';
      if (newValue === null) {
        displayValue = '';

      } else if (!this._isEmptyString(displayStartDateStr) && !this._isEmptyString(displayEndDateStr)) {
        displayValue = this.T("{0} to {1}", displayStartDateStr, displayEndDateStr)

      } else {
        displayValue = newValue;
      }

      this._setDisplayValue(displayValue);

      if (this.autoValidate) {
        this._detachUpdateDaterangeFromUserInputOnValidateHandler();
        this.validate();
        this._attachUpdateDaterangeFromUserInputOnValidateHandler();
      }

      this._fireValueChangedEvent(newValue);
    },

    /**
     * Flow 2. update interntal state from startDate and endDate when startDate and endDate are set externaly via property or attribute
     * We do not want to use _updateDaterangeFromStartAndEndDate function to handle scenarios when startDate or endDate are updated internally
     */
    _updateDaterangeFromStartAndEndDate: function(startDate, endDate) {
      // NOTE Flow 2 _updateDaterangeFromStartAndEndDate handler is initally emptyFn because initialization is done in ready function
      // and _updateDaterangeFromStartAndEndDate handler is attached in ready function    
    },

    _attachUpdateDaterangeFromStartAndEndDateHandler: function() { this._updateDaterangeFromStartAndEndDate = this._updateDaterangeFromStartAndEndDateImpl; },
    _detachUpdateDaterangeFromStartAndEndDateHandler: function() { this._updateDaterangeFromStartAndEndDate = this._emptyFn; },

    _updateDaterangeFromStartAndEndDateImpl: function(startDate, endDate) {
      // if startDate or endDate are undefined do nothing; output value and display Value should not change
      // there are tests that test for this behavior
      if (startDate === undefined || endDate === undefined) return;

      var startDateStr = new String(startDate);
      var endDateStr = new String(endDate);
      var startDateMoment = moment(startDateStr, this._valueFormat, true);
      var endDateMoment = moment(endDateStr, this._valueFormat, true);

      this._updateDaterangeFromStartAndEndDateMoments(startDateMoment, endDateMoment);
    },

    // Its probably better to split this function into three separate parts
    // 1. update start and end date pickers
    // 2. update display value 
    // 3. update output value
    // becuase we may need a more fine grained control for 
    // 1. when events are fired and 
    // 2. when internal functions are attached and detached
    _updateDaterangeFromStartAndEndDateMoments: function(startDateMoment, endDateMoment) {
      var startDateValid = startDateMoment.isValid();
      var endDateValid = endDateMoment.isValid();

      var outputStartDateStr = '';
      var outputEndDateStr = '';
      var displayStartDateStr = '';
      var displayEndDateStr = '';
      var pickerStartDateStr = '';
      var pickerEndDateStr = '';
      var localizedDateFormat = this._localizedFormat("date");

      if (startDateValid) {
        outputStartDateStr = startDateMoment.format(this._valueFormat);
        displayStartDateStr = startDateMoment.format(this._displayFormat);
        pickerStartDateStr = startDateMoment.format(localizedDateFormat);

      } else {
        var startDateInputStr = startDateMoment.creationData().input;
        displayStartDateStr = startDateInputStr;
        outputStartDateStr = startDateInputStr;
      }

      if (endDateValid) {
        outputEndDateStr = endDateMoment.format(this._valueFormat);
        displayEndDateStr = endDateMoment.format(this._displayFormat);
        pickerEndDateStr = endDateMoment.format(localizedDateFormat);

      } else {
        var endDateInputStr = endDateMoment.creationData().input;
        displayEndDateStr = endDateInputStr;
        outputEndDateStr = endDateInputStr;
      }

      // update display value
      var displayValue = displayStartDateStr.length > 0 && displayEndDateStr.length > 0 ? this.T("{0} to {1}", displayStartDateStr, displayEndDateStr) : '';
      this._setDisplayValue(displayValue);

      // update start and end date pickers
      this._updateDatePickerDates(this.$.startDatePicker, pickerStartDateStr, pickerEndDateStr);
      this._updateDatePickerDates(this.$.endDatePicker, pickerStartDateStr, pickerEndDateStr);

      // update output value
      var outputValue = this._isEmptyString(outputStartDateStr) && this._isEmptyString(outputEndDateStr) ? '/' : this.T("{0}/{1}", outputStartDateStr, outputEndDateStr);
      if (this.value !== outputValue) {
        // we want to prevent polymer-js from triggering FLOW 1 when this.value is set
        this._detachValueChangedHandler();
        this.value = outputValue;
        this._attachValueChangedHandler();

        // NOTE this can be problematic becuase whoever is handling the event can call functions on at-form-daterange
        // while daterange still didn't complete the processing 
        this._fireValueChangedEvent(outputValue);
      }
    },


    /**
     * Flow 3. startDatePicker and endDatePicker event management
     */
    _attachStartDatePickerStartDateChangedEventHandler: function() { 
      if (!this._boundStartDateChangedEventHandler) {
        this._boundStartDateChangedEventHandler = this._startDatePickerStartDateChangedEventHandler.bind(this);
      }
      this.$.startDatePicker.addEventListener('start-date-changed', this._boundStartDateChangedEventHandler);
    },
    
    _detachStartDatePickerStartDateChangedEventHandler: function() { 
      if (!this._boundStartDateChangedEventHandler) return;
      this.$.startDatePicker.remove('start-date-changed', this._boundStartDateChangedEventHandler);
    },
    
    _startDatePickerStartDateChangedEventHandler: function(event) { 
      var startDateValue = event.detail.value;
      var localizedDateFormat = this._localizedFormat("date");
      var startDateMoment = moment(startDateValue, localizedDateFormat, true);
      if (startDateMoment.isValid()) {
        var valueFormatStartDateStr = startDateMoment.format(this._valueFormat);
        this._updateDaterangeFromDatePickers(valueFormatStartDateStr, this.endDate);
      }
    },

    _attachEndDatePickerEndDateChangedEventHandler: function() { 
      if (!this._boundEndDateChangedEventHandler) {
        this._boundEndDateChangedEventHandler = this._endDatePickerEndDateChangedEventHandler.bind(this);
      }
      this.$.endDatePicker.addEventListener('end-date-changed', this._boundEndDateChangedEventHandler);
    },
    
    _detachEndDatePickerEndDateChangedEventHandler: function() { 
      if (!this._boundEndDateChangedEventHandler) return;
      this.$.endDatePicker.removeEventListener('end-date-changed', this._boundEndDateChangedEventHandler);
    },
    
    _endDatePickerEndDateChangedEventHandler: function(event) { 
      var endDateValue = event.detail.value;
      var localizedDateFormat = this._localizedFormat("date");
      var endDateMoment = moment(endDateValue, localizedDateFormat, true);
      if (endDateMoment.isValid()) {
        var valueFormatEndDateStr = endDateMoment.format(this._valueFormat);
        this._updateDaterangeFromDatePickers(this.startDate, valueFormatEndDateStr);
      }
    },

    /**
     * Flow 3. daterange update logic
     */
    _updateDaterangeFromDatePickers: function(startDate, endDate) { this._updateDaterangeFromDatePickersImpl(startDate, endDate); },

    _attachUpdateDaterangeFromDatePickersHandler: function() { this._updateDaterangeFromDatePickers = this._updateDaterangeFromDatePickersImpl; },
    _detachUpdateDaterangeFromDatePickersHandler: function() { this._updateDaterangeFromDatePickers = this.emptyFn; },

    _updateDaterangeFromDatePickersImpl: function(startDate, endDate) {
      // update output value
      this._detachValueChangedHandler();
      var outputValue = this.T("{0}/{1}", startDate, endDate);
      this.value = outputValue;
      this._attachValueChangedHandler();
      this._fireValueChangedEvent(outputValue);

      // startDate and endDate should already be in _valueFormat
      var startDateMoment = moment(startDate, this._valueFormat, true);
      var endDateMoment = moment(endDate, this._valueFormat, true);

      // update startDate and endDate
      this._detachUpdateDaterangeFromStartAndEndDateHandler();
      this.startDate = startDate;
      this.endDate = endDate;
      this._attachUpdateDaterangeFromStartAndEndDateHandler();

      Polymer.dom(this.$.startDateValue).textContent = startDateMoment.format(this._displayFormat);
      this._fireStartDateChangedEvent(startDate);
      Polymer.dom(this.$.endDateValue).textContent = endDateMoment.format(this._displayFormat);
      this._fireEndDateChangedEvent(endDate);

      if (startDateMoment.isValid() && endDateMoment.isValid()) {
        // update display value
        this._updateDisplayValue(startDateMoment, endDateMoment, this._displayFormat, this.$.triggerRange);
      } else {
        // update display value
        var displayValue = this.T("{0} to {1}", startDate, endDate);
        this._setDisplayValue(displayValue);
      }

      // update datepickers
      var localizedDateFormat = this._localizedFormat("date");
      var startDateStr = startDateMoment.format(localizedDateFormat);
      var endDateStr = endDateMoment.format(localizedDateFormat);
      this._detachUpdateDaterangeFromDatePickersHandler();
      this.$.startDatePicker.startDate = startDateStr;
      this.$.startDatePicker.endDate = endDateStr;
      this.$.endDatePicker.startDate = startDateStr;
      this.$.endDatePicker.endDate = endDateStr;
      this._attachUpdateDaterangeFromDatePickersHandler();
    },

    /*
      Flow 4.
        _displayValue will be updated with latest user input
        _displayValue will be split into .startDate and .endDate
        .startDate and .endDate will be set from _displayValue parts and formatted according to _valueFormat
        .value will be updated with new .startDate and .endDate
        dropdown will be updated, "custom" will be selected and startDate and endDate will be set on datepickers
        in case of invalid values correct validation messages will be displayed

        any feedback will be blocked:
        setting .startDate/.endDate will not cause update of _displayValue
        setting .value will not cause update of _displayValue
        updating datepikcers will not cause update of _displayValue
    */
    _updateDaterangeFromUserInput: function(newValue) {
      this._lastUserInput = newValue;
      newValue = newValue.trim();
      if (!newValue.length) return;

      // get array of valid momentjs objects from user input string
      var validMoments = this._getValidMomentObjectsFromUserInputString(newValue);

      // if user input string doesn't provide two valid moments return
      if (validMoments.length !== 2) {
        return;
      }

      var startDateMoment = validMoments[0];
      var endDateMoment = validMoments[1];

      // update datepickers
      var localizedDateFormat = this._localizedFormat("date");
      var startDatePickerString = startDateMoment.format(localizedDateFormat);
      var endDatePickerString = endDateMoment.format(localizedDateFormat);
      var startDatePicker = this.$.startDatePicker;
      var endDatePicker = this.$.endDatePicker;

      this._detachUpdateDaterangeFromDatePickersHandler();
      this._updateDatePickerDates(startDatePicker, startDatePickerString, endDatePickerString);
      this._updateDatePickerDates(endDatePicker, startDatePickerString, endDatePickerString);
      this._isUpdateDaterangeFromDatePickers = false;
      this._attachUpdateDaterangeFromDatePickersHandler();

      var startDateValueString = startDateMoment.format(this._valueFormat);
      var endDateValueString = endDateMoment.format(this._valueFormat);
      var valueString = this.T("{0}/{1}", startDateValueString, endDateValueString);

      this._detachUpdateDaterangeFromStartAndEndDateHandler();
      this._detachValueChangedHandler();
      this.startDate = startDateValueString;
      this.endDate = endDateValueString;
      this.value = valueString;
      this._attachValueChangedHandler();
      this._attachUpdateDaterangeFromStartAndEndDateHandler();

      this._fireStartDateChangedEvent(startDateValueString);
      this._fireEndDateChangedEvent(endDateValueString);
      this._fireValueChangedEvent(valueString);

      this._selectedChanged("custom");
      this.$.coreDropdown.hide();
    },

    /**
     * Flow 5. update daterange from user input for at-core-form enter usecase
     */
    _updateDaterangeFromUserInputOnValidate: function(inputValue) {
      // NOTE Flow 5 _updateDaterangeFromUserInput handler is initally emptyFn because initialization is done in ready function
      // and _updateDaterangeFromUserInput handler is attached in ready function    
    },

    _attachUpdateDaterangeFromUserInputOnValidateHandler: function() { this._updateDaterangeFromUserInputOnValidate = this._updateDaterangeFromUserInputOnValidateImpl; },
    _detachUpdateDaterangeFromUserInputOnValidateHandler: function() { this._updateDaterangeFromUserInputOnValidate = this._emptyFn; },

    _updateDaterangeFromUserInputOnValidateImpl: function(inputValue) {
      /*
        we maintain _lastUserInput to protect against repeated ENTER keypresses
        user can type "lorem ipsum" into the input field and then press ENTER 14 times
        user input should be processed only the first time; other 13 times nothing should be done
      */
      if (this._lastUserInput && this._lastUserInput === inputValue) {
        return;
      } else {
        // if user has changed his input remember it
        this._lastUserInput = inputValue;
      }

      var pickerStartDateStr = '';
      var pickerEndDateStr = '';
      var startDateStr = '';
      var endDateStr = '';
      var valueStr = '';

      var inputString = inputValue.trim();

      if (inputString.length > 0) {
        var resultMoments = this._getValidMomentObjectsFromUserInputString(inputValue);

        if (resultMoments.length == 2) {
          // we have valid user input
          var localizedDateFormat = this._localizedFormat("date");
          pickerStartDateStr = resultMoments[0].format(localizedDateFormat);
          pickerEndDateStr = resultMoments[1].format(localizedDateFormat);
          startDateStr = resultMoments[0].format(this._valueFormat);
          endDateStr = resultMoments[1].format(this._valueFormat);
          valueStr = this.T("{0}/{1}", startDateStr, endDateStr);

        } else {
          valueStr = inputValue;
        }
      }

      // update date pickers
      this._detachUpdateDaterangeFromDatePickersHandler();
      this._updateDatePickerDates(this.$.startDatePicker, pickerStartDateStr, pickerEndDateStr);
      this._updateDatePickerDates(this.$.endDatePicker, pickerStartDateStr, pickerEndDateStr);
      this._attachUpdateDaterangeFromDatePickersHandler();
      
      // update start and end date properties 
      this._detachUpdateDaterangeFromStartAndEndDateHandler();
      this.startDate = startDateStr;
      this.endDate = endDateStr;
      this._attachUpdateDaterangeFromStartAndEndDateHandler();
      this._fireStartDateChangedEvent(startDateStr);
      this._fireEndDateChangedEvent(endDateStr);

      // update value property
      this._detachValueChangedHandler();
      this.value = valueStr;
      this._attachValueChangedHandler();
      this._fireValueChangedEvent(valueStr);
    },

    _updateDisplayValue: function(startDateMoment, endDateMoment, displayFormat, input) {
      var startDateDisplayStr = startDateMoment.format(displayFormat);
      var endDateDisplayStr = endDateMoment.format(displayFormat);
      var displayResult = this.T("{0} to {1}", startDateDisplayStr, endDateDisplayStr);

      this._lastUserInput = displayResult;
      input.value = displayResult;
    },

    _rangeItemClicked: function(event) {
      var value = event.target.getAttribute('value');
      this.$.coreDropdown.hide();
      this._selectedChanged(value);
    },

    _selectedChanged: function(newValue) {
      if (newValue.length == 0) return;

      var activeItem = this.$$('.range-item.active');
      if (activeItem) {
        var activeItemValue = activeItem.getAttribute('value');
        // if item clicked is the same as currently active, return because there is no need to repeat the work
        if (activeItemValue == newValue && newValue !== "custom") return;

        Polymer.dom(activeItem).classList.remove('active');
      }

      if (newValue === 'custom') {
        this._toggleDropdownPanel('customRangeSelection');
      }

      if (this._boundResizeHandler !== undefined) {
        this._boundResizeHandler();
      }
      if (newValue === 'custom') {
        this.$.coreDropdown.show();
      }

      var startDateMoment = moment();
      var endDateMoment = moment();
      switch (newValue) {
        case 'today':
          break;
        case 'yesterday':
          startDateMoment.subtract(1, "days");
          endDateMoment.subtract(1, "days");
          break;
        case 'last7days':
          startDateMoment.subtract(6, "days");
          break;
        case 'last30days':
          startDateMoment.subtract(30, "days");
          break;
        case 'thisMonth':
          startDateMoment.startOf("month");
          endDateMoment.endOf("month");
          break;
        case 'lastMonth':
          startDateMoment.subtract(1, "months").startOf("month");
          endDateMoment.subtract(1, "months").endOf("month");
          break;
        case 'custom':
          if (this.startDate !== '') {
            startDateMoment = moment(this.startDate, this._valueFormat, true);
          }
          if (this.endDate !== '') {
            endDateMoment = moment(this.endDate, this._valueFormat, true);
          }
          break;
      }
      if (newValue) {
        var liElem = this.$$('.range-item[value=' + newValue + ']');
        if (liElem) {
          Polymer.dom(liElem).classList.add('active');
        }
      }

      this._detachUpdateDaterangeFromStartAndEndDateHandler();
      this._detachInternalValidStateUpdateHandler();

      this._updateDaterangeFromStartAndEndDateMoments(startDateMoment, endDateMoment);

      if (startDateMoment.isValid()) {
        this.startDate = startDateMoment.format(this._valueFormat);
        Polymer.dom(this.$.startDateValue).textContent = startDateMoment.format(this._displayFormat);
        this._fireStartDateChangedEvent(this.startDate);
      }
      if (endDateMoment.isValid()) {
        this.endDate = endDateMoment.format(this._valueFormat);
        Polymer.dom(this.$.endDateValue).textContent = endDateMoment.format(this._displayFormat);
        this._fireEndDateChangedEvent(this.endDate);
      }

      this._attachUpdateDaterangeFromStartAndEndDateHandler();
      this._attachInternalValidStateUpdateHandler();
    },

    _customRangeItemClicked: function(event) {
      var target = event.target;
      var value = target.getAttribute('value');

      if (!value) {
        value = target.parentElement.getAttribute('value');
      }

      switch (value) {
        case 'back':
          this._toggleDropdownPanel('ranges', event);
          break;
        case 'startDate':
          this._toggleDropdownPanel('startDate', event);
          break;
        case 'endDate':
          this._toggleDropdownPanel('endDate', event);
          break;
      }
    },

    _toggleDropdownPanel: function(panelId, event) {
      var rangesPanel = this.$.ranges;
      var customRangeSelection = this.$.customRangeSelection;
      var calendarStart = this.$.calendarStart;
      var calendarEnd = this.$.calendarEnd;

      this.toggleClass('hidden', panelId !== 'ranges', rangesPanel);
      this.toggleClass('hidden', panelId !== 'customRangeSelection', customRangeSelection);
      this.toggleClass('hidden', panelId !== 'startDate', calendarStart);
      this.toggleClass('hidden', panelId !== 'endDate', calendarEnd);

      this.$.coreDropdown.hide();
      this.$.coreDropdown.show(event, this.$.triggerRangeIcon);
    },

    _toggleCoreDropdown: function(event) {
      if (!this.disabled) {
        var coreDropdown = this.$.coreDropdown;
        var relativeTo = this.$.triggerRangeIcon;
        /* ij on 30.09.2016 - Mega Hack to apply correct layout to coreDropdown
          If coreDropdown is already open, hide it
          If coreDropdown is closed, show it
          then call _boundResizeHandler to measure,
          then hide it, then open again
          When open again correct layout will be applied to dropdown
          OFC, this solution is mega retarded but welcome to HTML and DOM API
        */
        if (coreDropdown.isOpen()) {
          coreDropdown.hide();
        } else {
          coreDropdown.show(event, relativeTo);
          this._boundResizeHandler();
          coreDropdown.hide();
          coreDropdown.show(event, relativeTo);
        }
      }
    },

    _datepickerOnTap: function(event) {
      this._toggleDropdownPanel('customRangeSelection');
    },

    // *ij* the main purpose of this function is to validate startDate and endDate format when they are programmatically set
    _validateValueFormat: function(value) {
      var result = true;
      var valueParts = value.split(' to ');
      var startDate = valueParts[0];
      var endDate = valueParts[1];
      var dateFormat = this._displayFormat;

      var startDateValid = true;
      var endDateValid = true;

      if (value === '') {
        return true;
      }

      if (startDate !== undefined && startDate !== '') {
        startDateValid = moment(startDate, dateFormat).isValid();
      }

      if (endDate !== undefined && endDate !== '') {
        endDateValid = moment(endDate, dateFormat).isValid();
      }

      result = result && startDateValid && endDateValid;

      if (!startDateValid) {
        this._errorMessage = this.T('Start date is in invalid format. Enter start date in format {0}', dateFormat);
      } else if (!endDateValid) {
        this._errorMessage = this.T('End date is in invalid format. Enter end date in format {0}', dateFormat);
      }

      return result;
    },

    _fireStartDateChangedEvent: function(newValue) {
      this.fire('start-date-changed', {
        value: newValue
      }, {
          bubbles: false
        });
    },

    _fireEndDateChangedEvent: function(newValue) {
      this.fire('end-date-changed', {
        value: newValue
      }, {
          bubbles: false
        });
    },

    open: function(evnet) {
      if (!this.disabled) {
        this._boundResizeHandler();
        this.$.coreDropdown.open();
      }
    },

    close: function(event) {
      this.$.coreDropdown.close();
    },

    focus: function() {
      var trigger = this.$.triggerRange;
      trigger.focus();
    },

    _getFocusableElement: function() {
      var focusable = this.$.triggerRange;
      return focusable;
    },

    /***********************************************************************/
    // Helper Methods
    /***********************************************************************/
    /*
      As name says, it parses user input string and returns an array of valid momentjs objects

      input string can be in localized display format
      this.T("{0} to {1}")
      also hypen(-) format is supported

      * hyphen (-), preceded by any number of space characters and followed by any number of space characters.
      * ie. <start-date>-<end-date>,
      * <start-date>    -<end-date>,
      * <start-date>-   <end-date>,
      * <start-date>  -   <end-date>
    */
    _getValidMomentObjectsFromUserInputString: function(usertInputString) {
      var result = [];

      var parts = usertInputString.split(" ");
      var part;
      var tmpMoment;

      for (i = 0; i < parts.length; i++) {
        part = parts[i];
        if (!part.length) {
          continue;
        }

        tmpMoment = moment(part, this._displayFormat, true);
        if (tmpMoment.isValid()) {
          result.push(tmpMoment);
        }
      }

      return result;
    },

    /*
      As name says, it updates start date and end date of a given date picker
      form-daterange has startdate picker and enddate picker
      startDate and endDate strings should be in _localizedFormat("date")
    */
    _updateDatePickerDates: function(datePicker, startDateString, endDateString) {
      datePicker.startDate = startDateString;
      datePicker.endDate = endDateString;
    },

    /*
      As name says, it sets display value for the daterange
      form-daterange has input field at $.triggerRange
      this function sets triggerRange value to displayValue
      and updates _lastUserInput to displayValue to prevent unnecessary flow5 from happening
    */
    _setDisplayValue: function(displayValue) {
      this._lastUserInput = displayValue;
      this.$.triggerRange.value = displayValue;
    },

    _isString: function(obj) {
      return Object.prototype.toString.call(obj) === "[object String]";
    },

    _isEmptyString: function(obj) {
      return Object.prototype.toString.call(obj) === "[object String]" && obj.length === 0;
    }

  });
</script>
