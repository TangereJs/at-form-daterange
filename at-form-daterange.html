<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="at-form-daterange-dropdown.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-carbon-icon/at-carbon-icon.html">
<link rel="import" href="../at-form-behaviors/at-form-behaviors.html">
<link rel="import" href="at-form-daterange-input-validation-behavior.html">

<!-- This is a new component extracted from the demo.html for polymer 0.5 -->

<dom-module id="at-form-daterange">
  <template>
    <style include="at-form-common"></style>
    <style>
      :host * {
        box-sizing: border-box;
      }

      :host {
        @apply(--at-form-host);
      }

      #triggerContainer {
        @apply(--layout-horizontal);
      }

      .icon-background {
        color: var(--at-form-daterange-icon-text-color);
        width: 32px;
        height: 32px;
      }

      .dropdown-container {
        position: relative;
        display: block;
      }

      .ranges {
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        padding: 4px 8px;
        margin: 4px;
        min-width: 175px;
        min-height: 256px;
      }

      .ranges.hidden {
        display: none;
      }

      .ranges .range-item {
        padding: 4px 8px;
        margin: 2px 0;
        cursor: pointer;
        border-radius: 5px;
        @apply(--at-form-label-font);
        @apply(--at-text-selected);
      }

      .ranges .range-item.active,
      .ranges .range-item:hover {
        @apply(--at-text-primary-selected);
      }

      .custom-range {
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        padding: 4px 8px;
        margin: 4px;
        min-width: 175px;
        min-height: 256px;
      }

      .custom-range.hidden {
        display: none;
      }

      .custom-range .custom-range-item {
        padding: 4px 8px;
        margin: 2px 0;
        cursor: pointer;
        border-radius: 5px;
        flex: 3;
        @apply(--at-form-label-font);
        @apply(--at-text-selected);
        display: flex;
        justify-content: center;
        flex-direction: column;
        text-align: center;
      }

      .custom-range .custom-range-item.active,
      .custom-range .custom-range-item:hover {
        @apply(--at-text-primary-selected);
      }

      .picker-header {
        text-align: center;
        position: relative;
        line-height: 40px;
      }

      .picker-header .confirm-icon {
        position: absolute;
        right: 0;
        top: 0;
      }

      .picker-header-hr {
        margin: 0 4px;
        opacity: 0.5;
      }

    </style>
    <div id="atContainer" class="at-container">
      <label id="label">{{label}}</label>
      <div id="contentContainer" class="at-content-container">
        <div id="triggerContainer" class="input-group">
          <input id="triggerRange" class="at-content has-placeholder date">
          <at-carbon-icon-button id="triggerRangeIcon" class="icon-background input-group-addon" icon="now:calendar"></at-carbon-icon-button>
        </div>
        <at-core-dropdown id="coreDropdown" class="core-dropdown" position="bottomRight">
          <div id="dropdown" class="">
            <div id="ranges" class="ranges">
              <div class="range-item" on-tap="_rangeItemClicked" value="today">{{T("Today")}}</div>
              <div class="range-item" on-tap="_rangeItemClicked" value="yesterday">{{T("Yesterday")}}</div>
              <div class="range-item" on-tap="_rangeItemClicked" value="last7days">{{T("Last 7 Days")}}</div>
              <div class="range-item" on-tap="_rangeItemClicked" value="last30days">{{T("Last 30 Days")}}</div>
              <div class="range-item" on-tap="_rangeItemClicked" value="thisMonth">{{T("This Month")}}</div>
              <div class="range-item" on-tap="_rangeItemClicked" value="lastMonth">{{T("Last Month")}}</div>
              <div class="range-item" on-tap="_rangeItemClicked" value="custom">{{T("Custom")}}</div>
            </div>
            <div id="customRangeSelection" class="custom-range hidden">
              <div class="custom-range-item" on-tap="_customRangeItemClicked" value="back">{{T("Custom")}}</div>
              <div class="custom-range-item" on-tap="_customRangeItemClicked" value="startDate">{{T("Start")}}: <span id="startDateValue"></span></div>
              <div class="custom-range-item" on-tap="_customRangeItemClicked" value="endDate">{{T("End")}}: <span id="endDateValue"></span></div>
            </div>
            <div id="calendarStart" class="at-carbon-picker-container hidden">
              <div class="picker-header">Select start date <at-carbon-icon-button class="confirm-icon" on-tap="_datepickerOnTap" icon="now:checkmark"></at-carbon-icon-button></div>
              <hr class="picker-header-hr"/>
              <at-carbon-date-picker id="startDatePicker" mode="start-range"></at-carbon-date-picker>
            </div>
            <div id="calendarEnd" class="at-carbon-picker-container hidden">
              <div class="picker-header">Select end date <at-carbon-icon-button class="confirm-icon" on-tap="_datepickerOnTap" icon="now:checkmark"></at-carbon-icon-button></div>
              <hr class="picker-header-hr"/>
              <at-carbon-date-picker id="endDatePicker" mode="end-range"></at-carbon-date-picker>
            </div>
          </div>
        </at-core-dropdown>
      </div>
      <div id="hint"></div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'at-form-daterange',
    behaviors: [Tangere.behaviors.i18n, Tangere.behaviors.formUIGeneric, Tangere.behaviors.AtFormDaterangeInputValidation],
    properties: {
      label: {
        type: String,
        value: '',
        title: 'Label'
      },

      hideLabel: {
        type: Boolean,
        value: false,
        observer: '_hideLabelChanged',
        title: 'Do not show the label'
      },

      disabled: {
        type: Boolean,
        value: false,
        observer: '_disabledChanged',
        title: 'Field value can not be changed'
      },

      /**
       * Hides the element. When hidden nothing is displayed for the element
       * @property hide
       * @type Boolean
       * @default false
       */
      hide: {
        type: Boolean,
        value: false,
        observer: '_hideChanged',
        title: 'Field is invisible'
      },

      required: {
        type: Boolean,
        value: false,
        title: 'Input required'
      },

      format: {
        type: String,
        value: '',
        observer: '_formatChanged',
        title: 'Format'
      },

      startDate: {
        type: String,
        value: '',
        title: 'Start Date'
      },

      endDate: {
        type: String,
        value: '',
        title: 'End Date'
      },

      value: {
        type: String,
        observer: '_valueChanged',
        value: '',
        title: 'Value'
      }
    },

    listeners: {
      'triggerRangeIcon.keydown': '_host_onKeydown',
      'triggerRangeIcon.tap': '_iconButtonMouseDown'
    },

    observers: [
      '_updateDaterangeFromStartAndEndDate(startDate, endDate)',
      '_internalValidStateUpdate(required, startDate, endDate)'
    ],

    $meta: [{
      title: "Daterange",
      type: "daterange",
      events: ["value-changed"]
    }],

    _keyCodes: {
      ESC: 27
    },

    _host_onKeydown: function (event) {
      var keyCodes = this._keyCodes;
      var keyCode = event.which;
      var coreDropdown = this.$.coreDropdown;

      switch (keyCode) {
        case keyCodes.ESC:
          coreDropdown.hide();
          break;
        default:
          break;
      }
    },

    _iconButtonMouseDown: function(event) {
      this._toggleCoreDropdown(event);
    },

    _hideLabelChanged: function(newValue, oldValue) {
      var label = this.$.label;
      this.toggleClass("hidden", newValue, label);
    },

    ready: function() {
      var self = this;
      var coreDropdown = this.$.coreDropdown;

      this._boundResizeHandler = function() {};
      this.orientation = 'horizontal';
      var dropdown = this.$.dropdown;
      var coreDropdown = this.$.coreDropdown;
      this.toggleClass('horizontal', this.orientation === 'horizontal', dropdown);
      this.toggleClass('vertical', this.orientation === 'vertical', dropdown);
      var contentContainer = this.$.contentContainer;
      var resizeUnboundHandler = function(event) {
        var windowWidth = contentContainer.getBoundingClientRect().width;
        var dropdownWidth = dropdown.getBoundingClientRect().width;
        var dropdownLeft = dropdown.getBoundingClientRect().left;
        if (self.orientation === 'horizontal') {
          if (dropdownWidth > windowWidth) {
            self.toggleClass('horizontal', false, dropdown);
            self.toggleClass('vertical', true, dropdown);
            self.orientation = 'vertical';
          } else {
            self.toggleClass('horizontal', true, dropdown);
            self.toggleClass('vertical', false, dropdown);
          }
        } else if (self.orientation === 'vertical') {
          if (dropdownWidth * 3 > windowWidth) {
            self.toggleClass('horizontal', false, dropdown);
            self.toggleClass('vertical', true, dropdown);
          } else {
            self.toggleClass('horizontal', true, dropdown);
            self.toggleClass('vertical', false, dropdown);
            self.orientation = 'horizontal';
          }
        }
        if (coreDropdown.isOpen()) {
          coreDropdown.hide();
          coreDropdown.show();
        }
      }

      var boundResizeHandler = resizeUnboundHandler.bind(this);
      window.addEventListener('resize', boundResizeHandler);
      this._boundResizeHandler = boundResizeHandler;

      var startDatePicker = this.$.startDatePicker;
      var endDatePicker = this.$.endDatePicker;
      startDatePicker.addEventListener('start-date-changed', function(event) {
        if (self._isInternalUpdateValue) {
          return;
        }
        self._isInternalUpdateValue = true;
        var startDateValue = event.detail.value;
        var localizedDateFormat = self._localizedFormat("date");
        var startDateMoment = moment(startDateValue, localizedDateFormat, true);
        if (startDateMoment.isValid()) {
          var valueFormatStartDateStr = startDateMoment.format(self._valueFormat);
          self._updateDaterangeFromDatePickers(valueFormatStartDateStr, self.endDate);
        }
        self._isInternalUpdateValue = false;
      });

      endDatePicker.addEventListener('end-date-changed', function(event) {
        if (self._isInternalUpdateValue) {
          return;
        }
        self._isInternalUpdateValue = true;
        var endDateValue = event.detail.value;
        var localizedDateFormat = self._localizedFormat("date");
        var endDateMoment = moment(endDateValue, localizedDateFormat, true);
        if (endDateMoment.isValid()) {
          var valueFormatEndDateStr = endDateMoment.format(self._valueFormat);
          self._updateDaterangeFromDatePickers(self.startDate, valueFormatEndDateStr);
        }
        self._isInternalUpdateValue = false;
      });

      this.$.triggerRange.addEventListener('change', function(event) {
        var value = event.target.value;
        self._updateDaterangeFromUserInput(value);
        self.validate();
      });

      this.$.triggerRange.addEventListener('blur', function(event) {
        self.validate();
      });

      this._valueFormat = "YYYY-MM-DD",
      this._isReady = true;
      if (!this._displayFormat) {
        this._displayFormat = this._localizedFormat("date");
      }
      this._internalValidStateUpdate(this.required, this.startDate, this.endDate);

      // Handle setting initial values
      function isString(obj) {
        return Object.prototype.toString.call(obj) === "[object String]";
      }
      var value = this.value;
      var startDate = this.startDate;
      var endDate = this.endDate;
      if (value === null || (isString(value) && value.length > 0)) {

        // If value is set, split value into startDate and endDate and update startDate, endDate, _displayValue and date pickers
        // we accept null, and value.length > 0 filters initial value of ""
        // name of the function is _valueChanged on purpose because it follows polymer-js naming convention(s)
        this._valueChanged(value);
      } else if (
        (isString(startDate) && startDate.length > 0) ||
        (isString(endDate) && endDate.length > 0)
      ) {

        // If value is not set, check if startDate and endDate are set and update value, _displayValue and date pickers
        // we do not accept null; startDate and endDate must be non empty strings
        this._updateDaterangeFromStartAndEndDate(startDate, endDate);
      } else {
        // else set everything to initial values
        this._valueChanged(this.properties.value.value);
      }
    },

    _disabledChanged: function(newValue, oldValue) {
      var triggerRange = this.$.triggerRange;
      this.toggleAttribute('disabled', newValue, triggerRange);
      var triggerRangeIcon = this.$.triggerRangeIcon;
      this.toggleAttribute('disabled', newValue, triggerRangeIcon);
      var atContainer = this.$.atContainer;
      this.toggleClass('disabled', newValue, atContainer);
    },

    _hideChanged: function(newValue, oldValue) {
      var wrapper = this.$.atContainer;
      this.toggleClass('hidden', newValue, wrapper);
    },

    _internalValidStateUpdate: function(required, startDate, endDate) {
      if (this._isReady) {
        this._isBlockFlow5 = true;
        this.validate();
        this._isBlockFlow5 = false;
      }
    },

    _formatChanged: function(newValue, oldValue) {
      function isString(obj) {
        return Object.prototype.toString.call(obj) === "[object String]";
      }
      var format = newValue;
      if (!isString(format) || format === "") {
        return;
      }

      if (!this._containsChars(['Y', 'M', 'D'], format) || this._containsChars(['h', 'm', 's'], format)) {
        // set format to the default format for date
        format = this._localizedFormat("date");
        // log the error
        console.log('Value ' + newValue + ' is not a valid format for date. Using default, ' + format + ', format instead.');
      }
      this._displayFormat = format;
      this.format = format;
      this.fire('format-changed', {
        value: format
      });

      /*
       * reformat display value to new format
       */
      var startDateMoment = moment(this.startDate, this._valueFormat, true);
      var endDateMoment = moment(this.endDate, this._valueFormat, true);
      this._updateDisplayValue(startDateMoment, endDateMoment, this._displayFormat, this.$.triggerRange);
    },
    /**
     * checks if source contains any of the chars
     * @param {Array} chars
     * @param {String} source
     */
    _containsChars: function(chars, source) {
      var result = false;
      chars.forEach(function(char, index) {
        result = result || source.indexOf(char) !== -1;
      });
      return result;
    },

    validate: function(showError) {

      if (showError === undefined) {
        showError = this.autoValidate;
      }

      var inputValue = this.$.triggerRange.value;
      if ((this.value === null && inputValue !== "") || (this.value !== null && this.value !== inputValue)) {
        this._flow5_updateDaterangeFromUserInput(inputValue);
      }

      var validationResult = this._validateBaseData();
      this._handleValidationResult(validationResult);
      if (!validationResult.isValid) {
        return validationResult.isValid;
      }

      // validate user input
      // newValue is user input
      var newValue = this.$.triggerRange.value;
      var trimmedNewvalue = newValue.trim();
      if (["null", null, ""].indexOf(trimmedNewvalue) === -1) {

        var validMoments = this._getValidMomentObjectsFromUserInputString(trimmedNewvalue);

        if (validMoments.length !== 2) {
          validationResult = {
            isValid: false,
            errorMessage: this.T("Input string {0} is not valid", newValue)
          };
        }

        if (showError) {
          this._handleValidationResult(validationResult);
        }

        if (!validationResult.isValid) {
          return validationResult.isValid;
        }
      }

      validationResult = this._validateData(this, this.value, this.T.bind(this));
      if (showError) {
        this._handleValidationResult(validationResult);
      }

      return validationResult.isValid;
    },

    _updateUIValidState: function(isValid) {
      var label = this.$.label;
      this.toggleClass('error', !isValid, label);
      var contentContainer = this.$.contentContainer;
      this.toggleClass('error', !isValid, contentContainer);
    },

    /*
      Flow 1. value is set as attribute or property
        * .value will be split into start date and end date
        * .startDate and .endDate will be set from .value parts and formatted according to _valueFormat
        * _displayValue will be updated and formatted according to _displayFormat
        * dropdown will  be updated, "custom" will be selected and startDate and endDate will be set on datepickers
        * in case of invalid values correct validation messages will be displayed

        * any feedback will  be blocked:
          * setting .startDate/.endDate will not cause recalculation of .value
          * setting _displayValue will not cause recalculation of .value
          * updating datepikcers will not cause recalculation of .value
    */
    _valueChanged: function (newValue, oldValue) {
      function isString(obj) {
        return Object.prototype.toString.call(obj) === "[object String]";
      }
      // !this._isReady ignore initial polymer-js initialization
      // we manually initialize from ready function
      // this._isInternalUpdateValue to block feedback
      if (!this._isReady || this._isInternalUpdateValue) {
        return;
      }
      this._isInternalUpdateValue = true;

      if (newValue === null) {
        // update display value to empty string
        this._setDisplayValue("");

        // update datepickers to ... what?
        this._isUpdateDaterangeFromDatePickers = true;
        this.$.startDatePicker.startDate = "";
        this.$.startDatePicker.endDate = "";
        this.$.endDatePicker.startDate = "";
        this.$.endDatePicker.endDate = "";
        this._isUpdateDaterangeFromDatePickers = false;
        // clear selection from dropdown
        this._selectedChanged("");

        // update startDate and endDate to null
        this.startDate = null;
        this._fireStartDateChangedEvent(startDateStr);
        this.endDate = null;
        this._fireEndDateChangedEvent(endDateStr);
      } else if (isString(newValue) && newValue.length > 0 && newValue.indexOf("/") !== -1) {
        // we expect newValue to be in ISO 8601 format <start-date>/<end-date>
        // in our case that is _valueFormat/_valueFormat
        var valueParts = newValue.split("/");

        var startDateStr = valueParts[0];
        var endDateStr = valueParts[1];
        var startDateMoment = moment(startDateStr, this._valueFormat, true);
        var endDateMoment = moment(endDateStr, this._valueFormat, true);
        if (startDateMoment.isValid() && endDateMoment.isValid()) {
          // update display value
          this._updateDisplayValue(startDateMoment, endDateMoment, this._displayFormat, this.$.triggerRange);
          // update datepickers
          // datepickers expect strings in _localizedFormat("date") so we need to provide
          var localizedDateFormat = this._localizedFormat("date");
          var localizedStartDateStr = startDateMoment.format(localizedDateFormat);
          var localizedEndDateStr = endDateMoment.format(localizedDateFormat);
          this._isUpdateDaterangeFromDatePickers = true;
          this.$.startDatePicker.startDate = localizedStartDateStr;
          this.$.startDatePicker.endDate = localizedEndDateStr;
          this.$.endDatePicker.startDate = localizedStartDateStr;
          this.$.endDatePicker.endDate = localizedEndDateStr;
          this._isUpdateDaterangeFromDatePickers = false;
        } else {
          this._setDisplayValue(newValue);
          this._isUpdateDaterangeFromDatePickers = true;
          this.$.startDatePicker.startDate = "";
          this.$.startDatePicker.endDate = "";
          this.$.endDatePicker.startDate = "";
          this.$.endDatePicker.endDate = "";
          this._isUpdateDaterangeFromDatePickers = false;
        }

        this.startDate = startDateStr;
        this._fireStartDateChangedEvent(startDateStr);
        this.endDate = endDateStr;
        this._fireEndDateChangedEvent(endDateStr);

      } else {
        // string is invalid
        // update startDate and endDate
        this.startDate = "";
        this.endDate = "";

        // update display value
        this._setDisplayValue(newValue);

        // update datepickers
        this._isUpdateDaterangeFromDatePickers = true;
        this.$.startDatePicker.startDate = "";
        this.$.startDatePicker.endDate = "";
        this.$.endDatePicker.startDate = "";
        this.$.endDatePicker.endDate = "";
        this._isUpdateDaterangeFromDatePickers = false;
      }

      if (this.autoValidate) {
        this._isBlockFlow5 = true;
        this.validate();
        this._isBlockFlow5 = false;
      }

      this._fireValueChangedEvent(newValue);
      this._isInternalUpdateValue = false;
    },

    /*
      Flow 2.
    */
    // compute value computes the value from startDate and endDate
    _updateDaterangeFromStartAndEndDate: function(startDate, endDate) {
      function isString(obj) {
        return Object.prototype.toString.call(obj) === "[object String]";
      }
      function isEmptyString(obj) {
        return Object.prototype.toString.call(obj) === "[object String]" && obj.length === 0;
      }

      if (!this._isReady || this._isInternalUpdateValue) {
        return;
      }
      this._isInternalUpdateValue = true;

      var result = '';

      if (isString(startDate) && isString(endDate) && startDate !== "" && endDate !== "") {
        this._fireStartDateChangedEvent(startDate);
        this._fireEndDateChangedEvent(endDate);

        var startDateMoment = moment(startDate, this._valueFormat, true);
        var endDateMoment = moment(endDate, this._valueFormat, true);

        var startDateValid = startDateMoment.isValid();
        var endDateValid = endDateMoment.isValid()

        if (startDateValid && endDateValid) {
          // update display value
          this._updateDisplayValue(startDateMoment, endDateMoment, this._displayFormat, this.$.triggerRange);

          // update date pickers
          var localizedDateFormat = this._localizedFormat("date");
          var startDateStr = startDateMoment.format(localizedDateFormat);
          var endDateStr = endDateMoment.format(localizedDateFormat);
          this._isUpdateDaterangeFromDatePickers = true;
          this.$.startDatePicker.startDate = startDateStr;
          this.$.startDatePicker.endDate = endDateStr;
          this.$.endDatePicker.startDate = startDateStr;
          this.$.endDatePicker.endDate = endDateStr;
          this._isUpdateDaterangeFromDatePickers = false;

          this._selectedChanged("custom");

          // update output value
          var outputValue = this.T("{0}/{1}", startDate, endDate);
          if (this.value !== outputValue) {
            this.value = outputValue;
            this._fireValueChangedEvent(outputValue);
          }
        } else {
          // update display value
          var displayValue = this.T("{0} to {1}", startDate, endDate);
          this._setDisplayValue(displayValue);

          // update date pickers
          this._isUpdateDaterangeFromDatePickers = true;
          this.$.startDatePicker.startDate = "";
          this.$.startDatePicker.endDate = "";
          this.$.endDatePicker.startDate = "";
          this.$.endDatePicker.endDate = "";
          this._isUpdateDaterangeFromDatePickers = false;

          this._selectedChanged("");

          // update output value
          var outputValue = this.T("{0}/{1}", startDate, endDate);
          if (this.value !== outputValue) {
            this.value = outputValue;
            this._fireValueChangedEvent(outputValue);
          }
        }
      } else if (startDate === "" || endDate === "") {
        this._fireStartDateChangedEvent(startDate);
        this._fireEndDateChangedEvent(endDate);

        // update display value
        this._setDisplayValue("");

        // update datepickers
        this._isUpdateDaterangeFromDatePickers = true;
        this.$.startDatePicker.startDate = "";
        this.$.startDatePicker.endDate = "";
        this.$.endDatePicker.startDate = "";
        this.$.endDatePicker.endDate = "";
        this._isUpdateDaterangeFromDatePickers = false;

        this._selectedChanged("");

        // update output value
        var outputValue = this.T("{0}/{1}", startDate, endDate);
        if (this.value !== outputValue) {
          this.value = outputValue;
          this._fireValueChangedEvent(outputValue);
        }
      } else {
        this._fireStartDateChangedEvent(startDate);
        this._fireEndDateChangedEvent(endDate);

        // start date and end date are not strings
        var startDateStr = String(startDate);
        var endDateStr = String(endDate);

        // update display value
        var displayValue = this.T("{0} to {1}", startDateStr, endDateStr);
        this._setDisplayValue(displayValue);

        // update datepickers
        this._isUpdateDaterangeFromDatePickers = true;
        this.$.startDatePicker.startDate = "";
        this.$.startDatePicker.endDate = "";
        this.$.endDatePicker.startDate = "";
        this.$.endDatePicker.endDate = "";
        this._isUpdateDaterangeFromDatePickers = false;

        this._selectedChanged("");

        // update output value
        var outputValue = this.T("{0}/{1}", startDateStr, endDateStr);
        if (this.value !== outputValue) {
          this.value = outputValue;
          this._fireValueChangedEvent(outputValue);
        }
      }

      this._isInternalUpdateValue = false;
    },

    /*
      Flow 3.
    */
    _updateDaterangeFromDatePickers: function(startDate, endDate) {
      if (!this._isReady || this._isUpdateDaterangeFromDatePickers) {
        return;
      }
      this._isUpdateDaterangeFromDatePickers = true;
      // startDate and endDate should already be in _valueFormat
      var startDateMoment = moment(startDate, this._valueFormat, true);
      var endDateMoment = moment(endDate, this._valueFormat, true);

      // update startDate and endDate
      this.startDate = startDate;
      Polymer.dom(this.$.startDateValue).textContent = startDateMoment.format(this._displayFormat);
      this._fireStartDateChangedEvent(startDate);
      this.endDate = endDate;
      Polymer.dom(this.$.endDateValue).textContent = endDateMoment.format(this._displayFormat);
      this._fireEndDateChangedEvent(endDate);

      if (startDateMoment.isValid() && endDateMoment.isValid()) {
        // update display value
        this._updateDisplayValue(startDateMoment, endDateMoment, this._displayFormat, this.$.triggerRange);
      } else {
        // update display value
        var displayValue = this.T("{0} to {1}", startDate, endDate);
        this._setDisplayValue(displayValue);
      }

      // update output value
      var outputValue = this.T("{0}/{1}", startDate, endDate);
      this.value = outputValue;
      this._fireValueChangedEvent(outputValue);

      // update datepickers
      var localizedDateFormat = this._localizedFormat("date");
      var startDateStr = startDateMoment.format(localizedDateFormat);
      var endDateStr = endDateMoment.format(localizedDateFormat);
      this.$.startDatePicker.startDate = startDateStr;
      this.$.startDatePicker.endDate = endDateStr;
      this.$.endDatePicker.startDate = startDateStr;
      this.$.endDatePicker.endDate = endDateStr;

      this._isUpdateDaterangeFromDatePickers = false;
    },

    /*
      Flow 4.
        _displayValue will be updated with latest user input
        _displayValue will be split into .startDate and .endDate
        .startDate and .endDate will be set from _displayValue parts and formatted according to _valueFormat
        .value will be updated with new .startDate and .endDate
        dropdown will be updated, "custom" will be selected and startDate and endDate will be set on datepickers
        in case of invalid values correct validation messages will be displayed

        any feedback will be blocked:
        setting .startDate/.endDate will not cause update of _displayValue
        setting .value will not cause update of _displayValue
        updating datepikcers will not cause update of _displayValue
    */
    _updateDaterangeFromUserInput: function (newValue) {
      this._lastUserInput = newValue;
      newValue = newValue.trim();
      if (!newValue.length) {
        return;
      }

      // get array of valid momentjs objects from user input string
      var validMoments = this._getValidMomentObjectsFromUserInputString(newValue);

      // if user input string doesn't provide two valid moments return
      if (validMoments.length !== 2) {
        return;
      }

      var startDateMoment = validMoments[0];
      var endDateMoment = validMoments[1];

      // update datepickers
      var localizedDateFormat = this._localizedFormat("date");
      var startDatePickerString = startDateMoment.format(localizedDateFormat);
      var endDatePickerString = endDateMoment.format(localizedDateFormat);
      var startDatePicker = this.$.startDatePicker;
      var endDatePicker = this.$.endDatePicker;

      this._isUpdateDaterangeFromDatePickers = true;
      this._updateDatePickerDates(startDatePicker, startDatePickerString, endDatePickerString);
      this._updateDatePickerDates(endDatePicker, startDatePickerString, endDatePickerString);
      this._isUpdateDaterangeFromDatePickers = false;

      var startDateValueString = startDateMoment.format(this._valueFormat);
      var endDateValueString = endDateMoment.format(this._valueFormat);
      var valueString = this.T("{0}/{1}", startDateValueString, endDateValueString);

      // update startDate value, endDate value and value
      this._isInternalUpdateValue = true;
      this.startDate = startDateValueString;
      this._fireStartDateChangedEvent(startDateValueString);
      this.endDate = endDateValueString;
      this._fireEndDateChangedEvent(endDateValueString);
      this.value = valueString;
      this._fireValueChangedEvent(valueString);
      this._isInternalUpdateValue = false;

      this._selectedChanged("custom");
      this.$.coreDropdown.hide();
    },

    /**
     * Flow 5. update daterange from user input for at-core-form enter usecase
     */
    _flow5_updateDaterangeFromUserInput: function(inputValue) {
      /*
        we maintain _lastUserInput to protect against repeated ENTER keypresses
        user can type "lorem ipsum" into the input field and then press ENTER 14 times
        user input should be processed only the first time; other 13 times nothing should be done
      */
      if (this._lastUserInput && this._lastUserInput === inputValue || this._isBlockFlow5) {
        return;
      } else {
        // if user has changed his input remember it
        this._lastUserInput = inputValue;
      }

      var startDatePicker = this.$.startDatePicker;
      var endDatePicker = this.$.endDatePicker;
      var inputString = inputValue.trim();

      if (inputString === "") {
        // clear existing value
        this._isUpdateDaterangeFromDatePickers = true;
        this._updateDatePickerDates(startDatePicker, "", "");
        this._updateDatePickerDates(endDatePicker, "", "");
        this._isUpdateDaterangeFromDatePickers = false;
        this._isInternalUpdateValue = true;
        this.startDate = "";
        this._fireStartDateChangedEvent("");
        this.endDate = "";
        this._fireEndDateChangedEvent("");
        this.value = "";
        this._fireValueChangedEvent(this.value);
        this._isInternalUpdateValue = false;
        return;
      }

      /*
        parse input string
      */
      var resultMoments = this._getValidMomentObjectsFromUserInputString(inputValue);

      if (resultMoments.length !== 2) {
        // user input is invalid;
        this._isUpdateDaterangeFromDatePickers = true;
        this._updateDatePickerDates(startDatePicker, "", "");
        this._updateDatePickerDates(endDatePicker, "", "");
        this._isUpdateDaterangeFromDatePickers = false;
        this._isInternalUpdateValue = true;
        this.startDate = "";
        this._fireStartDateChangedEvent("");
        this.endDate = "";
        this._fireEndDateChangedEvent("");
        this.value = inputValue;
        this._fireValueChangedEvent(this.value);
        this._isInternalUpdateValue = false;
      } else {
        // we have valid user input
        var localizedDateFormat = this._localizedFormat("date");
        var startDatePickerString = resultMoments[0].format(localizedDateFormat);
        var endDatePickerString = resultMoments[1].format(localizedDateFormat);
        var startDateValueString = resultMoments[0].format(this._valueFormat);
        var endDateValueString = resultMoments[1].format(this._valueFormat);
        var outputValue = this.T("{0}/{1}", startDateValueString, endDateValueString);

        this._isUpdateDaterangeFromDatePickers = true;
        this._updateDatePickerDates(startDatePicker, startDatePickerString, endDatePickerString);
        this._updateDatePickerDates(endDatePicker, startDatePickerString, endDatePickerString);
        this._isUpdateDaterangeFromDatePickers = false;

        this._isInternalUpdateValue = true;
        this.startDate = startDateValueString;
        this._fireStartDateChangedEvent(startDateValueString);
        this.endDate = endDateValueString;
        this._fireEndDateChangedEvent(endDateValueString);
        this.value = outputValue;
        this._fireValueChangedEvent(outputValue);
        this._isInternalUpdateValue = false;
      }
    },

    _updateDisplayValue: function (startDateMoment, endDateMoment, displayFormat, input) {
      var startDateDisplayStr = startDateMoment.format(displayFormat);
      var endDateDisplayStr = endDateMoment.format(displayFormat);
      var displayResult = this.T("{0} to {1}", startDateDisplayStr, endDateDisplayStr);

      this._lastUserInput = displayResult;
      input.value = displayResult;
    },

    _rangeItemClicked: function(event) {
      var value = event.target.getAttribute('value');
      this.$.coreDropdown.hide();
      this._selectedChanged(value);
    },

    _selectedChanged: function(newValue) {
      var self = this;

      if (this._isInternalUpdate || newValue === "") {
        return;
      }

      var activeItem = this.$$('.range-item.active');
      if (activeItem) {
        Polymer.dom(activeItem).classList.remove('active');
      }

      if (newValue === 'custom') {
        this._toggleDropdownPanel('customRangeSelection');
      }

      if (this._boundResizeHandler !== undefined) {
        this._boundResizeHandler();
      }
      if (newValue === 'custom') {
        this.$.coreDropdown.show();
      }
      this._isInternalUpdate = true;
      var startDateMoment = moment();
      var endDateMoment = moment();
      switch (newValue) {
        case 'today':
          break;
        case 'yesterday':
          startDateMoment.subtract(1, "days");
          endDateMoment.subtract(1, "days");
          break;
        case 'last7days':
          startDateMoment.subtract(6, "days");
          break;
        case 'last30days':
          startDateMoment.subtract(30, "days");
          break;
        case 'thisMonth':
          startDateMoment.startOf("month");
          endDateMoment.endOf("month");
          break;
        case 'lastMonth':
          startDateMoment.subtract(1, "months").startOf("month");
          endDateMoment.subtract(1, "months").endOf("month");
          break;
        case 'custom':
          if (this.startDate !== '') {
            startDateMoment = moment(this.startDate, this._valueFormat, true);
          }
          if (this.endDate !== '') {
            endDateMoment = moment(this.endDate, this._valueFormat, true);
          }
          break;
      }
      if (newValue) {
        var liElem = this.$$('.range-item[value=' + newValue + ']');
        if (liElem) {
          Polymer.dom(liElem).classList.add('active');
        }
      }

      if (startDateMoment.isValid()) {
        this.startDate = startDateMoment.format(this._valueFormat);
        Polymer.dom(this.$.startDateValue).textContent = startDateMoment.format(this._displayFormat);
        this._fireStartDateChangedEvent(this.startDate);
      }
      if (endDateMoment.isValid()) {
        this.endDate = endDateMoment.format(this._valueFormat);
        Polymer.dom(this.$.endDateValue).textContent = endDateMoment.format(this._displayFormat);
        this._fireEndDateChangedEvent(this.endDate);
      }
      this._isInternalUpdate = false;
    },

    _customRangeItemClicked: function (event) {
      var target = event.target;
      var value = target.getAttribute('value');

      if (!value) {
        value = target.parentElement.getAttribute('value');
      }

      switch (value) {
        case 'back':
          this._toggleDropdownPanel('ranges');
          break;
        case 'startDate':
          this._toggleDropdownPanel('startDate');
          break;
        case 'endDate':
          this._toggleDropdownPanel('endDate');
          break;
      }
    },

    _toggleDropdownPanel: function(panelId) {
      var rangesPanel = this.$.ranges;
      var customRangeSelection = this.$.customRangeSelection;
      var calendarStart = this.$.calendarStart;
      var calendarEnd = this.$.calendarEnd;

      this.toggleClass('hidden', panelId !== 'ranges', rangesPanel);
      this.toggleClass('hidden', panelId !== 'customRangeSelection', customRangeSelection);
      this.toggleClass('hidden', panelId !== 'startDate', calendarStart);
      this.toggleClass('hidden', panelId !== 'endDate', calendarEnd);

      this.$.coreDropdown.hide();
      this.$.coreDropdown.show(event, this.$.triggerRangeIcon);
    },

    _toggleCoreDropdown: function (event) {
      if (!this.disabled) {
        var coreDropdown = this.$.coreDropdown;
        var relativeTo = this.$.triggerRangeIcon;
        /* ij on 30.09.2016 - Mega Hack to apply correct layout to coreDropdown
          If coreDropdown is already open, hide it
          If coreDropdown is closed, show it
          then call _boundResizeHandler to measure,
          then hide it, then open again
          When open again correct layout will be applied to dropdown
          OFC, this solution is mega retarded but welcome to HTML and DOM API
        */
        if (coreDropdown.isOpen()) {
          coreDropdown.hide();
        } else {
          coreDropdown.show(event, relativeTo);
          this._boundResizeHandler();
          coreDropdown.hide();
          coreDropdown.show(event, relativeTo);
        }
      }
    },

    _datepickerOnTap: function (event) {
      this._toggleDropdownPanel('customRangeSelection');
    },

    // *ij* the main purpose of this function is to validate startDate and endDate format when they are programmatically set
    _validateValueFormat: function(value) {
      var result = true;
      var valueParts = value.split(' to ');
      var startDate = valueParts[0];
      var endDate = valueParts[1];
      var dateFormat = this._displayFormat;

      var startDateValid = true;
      var endDateValid = true;

      if (value === '') {
        return true;
      }

      if (startDate !== undefined && startDate !== '') {
        startDateValid = moment(startDate, dateFormat).isValid();
      }

      if (endDate !== undefined && endDate !== '') {
        endDateValid = moment(endDate, dateFormat).isValid();
      }

      result = result && startDateValid && endDateValid;

      if (!startDateValid) {
        this._errorMessage = this.T('Start date is in invalid format. Enter start date in format {0}', dateFormat);
      } else if (!endDateValid) {
        this._errorMessage = this.T('End date is in invalid format. Enter end date in format {0}', dateFormat);
      }

      return result;
    },

    _fireStartDateChangedEvent: function(newValue) {
      this.fire('start-date-changed', {
        value: newValue
      }, {
        bubbles: false
      });
    },

    _fireEndDateChangedEvent: function(newValue) {
      this.fire('end-date-changed', {
        value: newValue
      }, {
        bubbles: false
      });
    },

    open: function(evnet) {
      if (!this.disabled) {
        this._boundResizeHandler();
        this.$.coreDropdown.open();
      }
    },

    close: function(event) {
      this.$.coreDropdown.close();
    },

    focus: function() {
      var trigger = this.$.triggerRange;
      trigger.focus();
    },

    _getFocusableElement: function() {
      var focusable = this.$.triggerRange;
      return focusable;
    },

    /***********************************************************************/
    // Helper Methods
    /***********************************************************************/
    /*
      As name says, it parses user input string and returns an array of valid momentjs objects

      input string can be in localized display format
      this.T("{0} to {1}")
      also hypen(-) format is supported

      * hyphen (-), preceded by any number of space characters and followed by any number of space characters.
      * ie. <start-date>-<end-date>,
      * <start-date>    -<end-date>,
      * <start-date>-   <end-date>,
      * <start-date>  -   <end-date>
    */
    _getValidMomentObjectsFromUserInputString: function(usertInputString) {
      var result = [];

      var parts = usertInputString.split(" ");
      var part;
      var tmpMoment;

      for (i = 0; i < parts.length; i++) {
        part = parts[i];
        if (!part.length) {
          continue;
        }

        tmpMoment = moment(part, this._displayFormat, true);
        if (tmpMoment.isValid()) {
          result.push(tmpMoment);
        }
      }

      return result;
    },

    /*
      As name says, it updates start date and end date of a given date picker
      form-daterange has startdate picker and enddate picker
      startDate and endDate strings should be in _localizedFormat("date")
    */
    _updateDatePickerDates: function(datePicker, startDateString, endDateString) {
      datePicker.startDate = startDateString;
      datePicker.endDate = endDateString;
    },

    /*
      As name says, it sets display value for the daterange
      form-daterange has input field at $.triggerRange
      this function sets triggerRange value to displayValue
      and updates _lastUserInput to displayValue to prevent unnecessary flow5 from happening
    */
    _setDisplayValue: function (displayValue) {
      this._lastUserInput = displayValue;
      this.$.triggerRange.value = displayValue;
    }
  });
</script>
