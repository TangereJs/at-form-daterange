<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="at-form-daterange-dropdown.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-carbon-icon/at-carbon-icon.html">
<link rel="import" href="../at-form-behaviors/at-form-behaviors.html">

<!-- This is a new component extracted from the demo.html for polymer 0.5 -->

<dom-module id="at-form-daterange">
  <template>
    <style include="at-form-common"></style>
    <style>
      :host * {
        box-sizing: border-box;
      }

      :host {
        @apply(--at-form-host);
      }

      #triggerContainer {
        @apply(--layout-horizontal);
      }

      .icon-background {
        color: var(--at-form-daterange-icon-text-color);
        @apply(at-form-border-radius0220);
      }

      .dropdown-container {
        position: relative;
        display: block;
      }

      .core-dropdown .ranges {
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        padding: 4px 8px;
        margin: 4px;
        min-width: 175px;
      }

      .range-item {
        padding: 4px 8px;
        margin: 2px 0;
        cursor: pointer;
        border-radius: 5px;
        @apply(--at-form-label-font);
        @apply(--at-text-selected);
      }

      .core-dropdown .ranges .range-item.active,
      .core-dropdown .ranges .range-item:hover {
        @apply(--at-text-primary-selected);
      }

      .hidden {
        display: none;
      }
    </style>
    <div id="atContainer" class="at-container">
      <label id="label">{{label}}</label>
      <div id="contentContainer" class="at-content-container">
        <div id="triggerContainer" class="input-group">
          <input id="triggerRange" class="at-content has-placeholder date" value="{{value}}" on-mousedown="_triggerRangeMouseDown" readonly>
          <at-carbon-icon-button id="triggerRangeIcon" class="icon-background input-group-addon" on-mousedown="_iconButtonMouseDown" icon="now:calendar"></at-carbon-icon-button>
        </div>
        <at-core-dropdown id="coreDropdown" class="core-dropdown" position="bottomRight">
          <div id="dropdown" class="layout horizontal">
            <div class="ranges">
              <div class="range-item" on-click="_rangeItemClicked" value="today">{{T("Today")}}</div>
              <div class="range-item" on-click="_rangeItemClicked" value="yesterday">{{T("Yesterday")}}</div>
              <div class="range-item" on-click="_rangeItemClicked" value="last7days">{{T("Last 7 Days")}}</div>
              <div class="range-item" on-click="_rangeItemClicked" value="last30days">{{T("Last 30 Days")}}</div>
              <div class="range-item" on-click="_rangeItemClicked" value="thisMonth">{{T("This Month")}}</div>
              <div class="range-item" on-click="_rangeItemClicked" value="lastMonth">{{T("Last Month")}}</div>
              <div class="range-item" on-click="_rangeItemClicked" value="custom">{{T("Custom")}}</div>
            </div>
            <div id="calendarStart" class="at-carbon-picker-container hidden">
              <at-carbon-date-picker mode="start-range" start-date="{{startDate}}" end-date="{{endDate}}" format="[[format]]"></at-carbon-date-picker>
            </div>
            <div id="calendarEnd" class="at-carbon-picker-container hidden">
              <at-carbon-date-picker mode="end-range" start-date="{{startDate}}" end-date="{{endDate}}" format="[[format]]"></at-carbon-date-picker>
            </div>
          </div>
        </at-core-dropdown>
      </div>
      <div id="hint"></div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'at-form-daterange',
    behaviors: [Tangere.behaviors.i18n, Tangere.behaviors.formUIGeneric],
    properties: {
      label: {
        type: String,
        value: '',
        title: 'Label'
      },

      hideLabel: {
        type: Boolean,
        value: false,
        observer: '_hideLabelChanged',
        title: 'Do not show the label'
      },

      disabled: {
        type: Boolean,
        value: false,
        observer: '_disabledChanged',
        title: 'Field value can not be changed'
      },

      /**
       * Hides the element. When hidden nothing is displayed for the element
       * @property hide
       * @type Boolean
       * @default false
       */
      hide: {
        type: Boolean,
        value: false,
        observer: '_hideChanged',
        title: 'Field is invisible'
      },

      required: {
        type: Boolean,
        value: false,
        title: 'Input required'
      },

      format: {
        type: String,
        value: '',
        observer: '_formatChanged',
        title: 'Format'
      },

      startDate: {
        type: String,
        value: '',
        title: 'Start Date'
      },

      endDate: {
        type: String,
        value: '',
        title: 'End Date'
      },

      value: {
        type: String,
        computed: '_computeValue(startDate, endDate)',
        isReadOnly: true,
        title: 'Value'
      }
    },

    observers: [
      '_internalUpdateValidState(disabled, required, startDate, endDate)'
    ],

    $meta: [{
      title: "Daterange",
      type: "daterange",
      events: ["value-changed"]
    }],

    _hideLabelChanged: function(newValue, oldValue) {
      var label = this.$.label;
      this.toggleClass("hidden", newValue, label);
    },

    ready: function() {

      this._internalFormat = this._localizedFormat("date");
      this._lastFormatUsedForParsing = this._internalFormat;
      var self = this;
      var coreDropdown = this.$.coreDropdown;

      this._boundResizeHandler = function() {};
      this.orientation = 'horizontal';
      var dropdown = this.$.dropdown;
      var coreDropdown = this.$.coreDropdown;
      this.toggleClass('horizontal', this.orientation === 'horizontal', dropdown);
      this.toggleClass('vertical', this.orientation === 'vertical', dropdown);
      var contentContainer = this.$.contentContainer;
      var resizeUnboundHandler = function(event) {
        var windowWidth = contentContainer.getBoundingClientRect().width;
        var dropdownWidth = dropdown.getBoundingClientRect().width;
        var dropdownLeft = dropdown.getBoundingClientRect().left;
        if (self.orientation === 'horizontal') {
          if (dropdownWidth > windowWidth) {
            self.toggleClass('horizontal', false, dropdown);
            self.toggleClass('vertical', true, dropdown);
            self.orientation = 'vertical';
          } else {
            self.toggleClass('horizontal', true, dropdown);
            self.toggleClass('vertical', false, dropdown);
          }
        } else if (self.orientation === 'vertical') {
          if (dropdownWidth * 3 > windowWidth) {
            self.toggleClass('horizontal', false, dropdown);
            self.toggleClass('vertical', true, dropdown);
          } else {
            self.toggleClass('horizontal', true, dropdown);
            self.toggleClass('vertical', false, dropdown);
            self.orientation = 'horizontal';
          }
        }
        if (coreDropdown.isOpen()) {
          coreDropdown.hide();
          coreDropdown.show();
        }
      }

      this._isReady = true;
      this._internalUpdateValidState(this.disabled, this.required);
    },

    _disabledChanged: function(newValue, oldValue) {
      var atContainer = this.$.atContainer;
      this.toggleClass('disabled', newValue, atContainer);
    },

    _hideChanged: function(newValue, oldValue) {
      var wrapper = this.$.atContainer;
      this.toggleClass('hidden', newValue, wrapper);
    },

    _internalUpdateValidState: function (disabled, required, startDate, endDate) {
      if (this._isReady) {
        this.validate();
      }
    },

    _formatChanged: function(newValue, oldValue) {
      var format = newValue;
      if (format) {
        if (!this._containsChars(['Y', 'M', 'D'], format) || this._containsChars(['h', 'm', 's'], format)) {
          // set format to the default format for date
          format = this._internalFormat;
          this._lastFormatUsedForParsing = this._internalFormat;
          // log the error
          console.log('Value ' + newValue + ' is not a valid format for date. Using default, ' + format + ', format instead.');
        }
        this.format = format;
        this.fire('format-changed', {
          value: format
        });
        this._internalFormat = format;

        /*
         * reformat startDate and endDate to match new format
         */
        if (this._lastFormatUsedForParsing) {
          var newStartDate;
          var startMoment = moment(this.startDate, this._lastFormatUsedForParsing);
          if (startMoment.isValid()) {
            newStartDate = startMoment.format(format);
          }

          var newEndDate;
          var endMoment = moment(this.endDate, this._lastFormatUsedForParsing);
          if (endMoment.isValid()) {
            newEndDate = endMoment.format(format);
          }
          this._lastFormatUsedForParsing = format;
          this.startDate = newStartDate;
          this.endDate = newEndDate;
          this._fireStartDateChangedEvent(newStartDate);
          this._fireEndDateChangedEvent(newEndDate);
        }
      }
    },
    /**
     * checks if source contains any of the chars
     * @param {Array} chars
     * @param {String} source
     */
    _containsChars: function(chars, source) {
      var result = false;
      chars.forEach(function(char, index) {
        result = result || source.indexOf(char) !== -1;
      });
      return result;
    },

    validate: function(showError) {
      return true;
    },

    _updateUIValidState: function(isValid) {
      var label = this.$.label;
      this.toggleClass('error', !isValid, label);
      var contentContainer = this.$.contentContainer;
      this.toggleClass('error', !isValid, contentContainer);
    },

    // value is read only
    set value(newValue) { },

    // compute value computes the value from startDate and endDate
    _computeValue: function(startDate, endDate) {
      var valueStringTemplate = this.T("{0} to {1}");
      var result = '';
      if (startDate === "" || endDate === "") {
        return result;
      }
      if (startDate && endDate) {
        result = valueStringTemplate.replace("{0}", startDate).replace("{1}", endDate);
      }

      return result;
    },

    _rangeItemClicked: function(event) {
      var value = event.target.getAttribute('value');
      this.$.coreDropdown.hide();
      this._selectedChanged(value);
    },

    _selectedChanged: function(newValue) {
      if (newValue === "") {
        return;
      }
      var activeItem = this.$$('.range-item.active');
      if (activeItem) {
        Polymer.dom(activeItem).classList.remove('active');
      }
      var calendarStart = this.$.calendarStart;
      this.toggleClass('hidden', newValue !== 'custom', calendarStart);
      var calendarEnd = this.$.calendarEnd;
      this.toggleClass('hidden', newValue !== 'custom', calendarEnd);
      if (this._boundResizeHandler !== undefined) {
        this._boundResizeHandler();
      }
      if (newValue === 'custom') {
        this.$.coreDropdown.show();
      }
      this._isInternalUpdate = true;
      switch (newValue) {
        case 'today':
          this.startDate = this._formatDate(moment());
          this.endDate = this._formatDate(moment());
          break;
        case 'yesterday':
          this.startDate = this._formatDate(moment().subtract(1, "days"));
          this.endDate = this._formatDate(moment().subtract(1, "days"));
          break;
        case 'last7days':
          this.startDate = this._formatDate(moment().subtract(6, "days"));
          this.endDate = this._formatDate(moment());
          break;
        case 'last30days':
          this.startDate = this._formatDate(moment().subtract(30, "days"));
          this.endDate = this._formatDate(moment());
          break;
        case 'thisMonth':
          this.startDate = this._formatDate(moment().startOf("month"));
          this.endDate = this._formatDate(moment().endOf("month"));
          break;
        case 'lastMonth':
          this.startDate = this._formatDate(moment().subtract(1, "months").startOf("month"));
          this.endDate = this._formatDate(moment().subtract(1, "months").endOf("month"));
          break;
        case 'custom':
          // for initialization purposes (first time) startDate and endDate are set to today
          // subject to change
          if (this.startDate === '') {
            this.startDate = this._formatDate(moment());
          }
          if (this.endDate === '') {
            this.endDate = this._formatDate(moment());
          }
          break;
      }
      this._isInternalUpdate = false;
      if (newValue) {
        var liElem = this.$$('.range-item[value=' + newValue + ']');
        if (liElem) {
          Polymer.dom(liElem).classList.add('active');
        }
      }
      this._fireStartDateChangedEvent(this.startDate);
      this._fireEndDateChangedEvent(this.endDate);
    },

    _formatDate: function(moment) {
      if (!this.format) {
        // this.format = this._internalFormat;
      }
      return moment.format(this._internalFormat);
    },

    _triggerRangeMouseDown: function(event) {
      if (!this.disabled) {
        this.$.coreDropdown.toggle(this.$.triggerRangeIcon);
      }
    },

    _iconButtonMouseDown: function(event) {
      if (!this.disabled) {
        this.$.coreDropdown.toggle(this.$.triggerRangeIcon);
      }
    },

    // *ij* the main purpose of this function is to validate startDate and endDate format when they are programmatically set
    _validateValueFormat: function(value) {
      var result = true;
      var valueParts = value.split(' to ');
      var startDate = valueParts[0];
      var endDate = valueParts[1];
      var dateFormat = this._internalFormat;

      var startDateValid = true;
      var endDateValid = true;

      if (value === '') {
        return true;
      }

      if (startDate !== undefined && startDate !== '') {
        startDateValid = moment(startDate, dateFormat).isValid();
      }

      if (endDate !== undefined && endDate !== '') {
        endDateValid = moment(endDate, dateFormat).isValid();
      }

      result = result && startDateValid && endDateValid;

      if (!startDateValid) {
        this._errorMessage = this.T('Start date is in invalid format. Enter start date in format {0}', dateFormat);
      } else if (!endDateValid) {
        this._errorMessage = this.T('End date is in invalid format. Enter end date in format {0}', dateFormat);
      }

      return result;
    },

    _fireStartDateChangedEvent: function (newValue) {
      this.fire('start-date-changed', {
        value: newValue
      }, {
        bubbles: false
      });
    },

    _fireEndDateChangedEvent: function (newValue) {
      this.fire('end-date-changed', {
        value: newValue
      }, {
        bubbles: false
      });
    },

    open: function(evnet) {
      if (!this.disabled) {
        this.$.coreDropdown.open();
      }
    },

    close: function(event) {
      this.$.coreDropdown.close();
    },

    focus: function() {
      var trigger = this.$.triggerRange;
      trigger.focus();
    },

    _getFocusableElement: function() {
      var focusable = this.$.triggerRange;
      return focusable;
    }
  });
</script>
