<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="at-form-daterange-dropdown.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-carbon-icon/at-carbon-icon.html">
<link rel="import" href="../at-form-behaviors/at-form-behaviors.html">

<!-- This is a new component extracted from the demo.html for polymer 0.5 -->

<dom-module id="at-form-daterange">
  <template>
    <style include="at-form-common"></style>
    <style>
      :host * {
        box-sizing: border-box;
      }

      :host {
        @apply(--at-form-host);
      }

      #triggerContainer {
        @apply(--layout-horizontal);
      }

      .icon-background {
        color: var(--at-form-daterange-icon-text-color);
        @apply(at-form-border-radius0220);
      }

      .dropdown-container {
        position: relative;
        display: block;
      }

      .coreDropdown .ranges {
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        padding: 4px 8px;
        margin: 4px;
        min-width: 175px;
      }

      .range-item {
        padding: 4px 8px;
        margin: 2px 0;
        cursor: pointer;
        border-radius: 5px;
        @apply(--at-form-label-font);
        @apply(--at-text-selected);
      }

      .coreDropdown .ranges .range-item.active,
      .coreDropdown .ranges .range-item:hover {
        @apply(--at-text-primary-selected);
      }

      .hidden {
        display: none;
      }
    </style>
    <div id="atContainer" class="at-container">
      <label id="label">{{label}}</label>
      <div id="contentContainer" class="at-content-container">
        <div id="triggerContainer" class="input-group">
          <input id="triggerRange" class="at-content has-placeholder" value="{{value}}" on-mousedown="toggle" readonly class="date">
          <at-carbon-icon-button id="triggerRangeIcon" class="icon-background input-group-addon" on-mousedown="_buttonIconClick" icon="now:calendar"></at-carbon-icon-button>
        </div>
        <at-core-dropdown id="coreDropdown" class="coreDropdown" position="bottomRight">
          <div id="dropdown" class="layout horizontal">
            <div class="ranges">
              <div class="range-item" on-click="rangeItemClicked" value="today">{{T("Today")}}</div>
              <div class="range-item" on-click="rangeItemClicked" value="yesterday">{{T("Yesterday")}}</div>
              <div class="range-item" on-click="rangeItemClicked" value="last7days">{{T("Last 7 Days")}}</div>
              <div class="range-item" on-click="rangeItemClicked" value="last30days">{{T("Last 30 Days")}}</div>
              <div class="range-item" on-click="rangeItemClicked" value="thisMonth">{{T("This Month")}}</div>
              <div class="range-item" on-click="rangeItemClicked" value="lastMonth">{{T("Last Month")}}</div>
              <div class="range-item" on-click="rangeItemClicked" value="custom">{{T("Custom")}}</div>
            </div>
            <div id="calendarStart" class="at-carbon-picker-container hidden">
              <at-carbon-date-picker mode="start-range" start-date="{{startDate}}" end-date="{{endDate}}" format="[[format]]"></at-carbon-date-picker>
            </div>
            <div id="calendarEnd" class="at-carbon-picker-container hidden">
              <at-carbon-date-picker mode="end-range" start-date="{{startDate}}" end-date="{{endDate}}" format="[[format]]"></at-carbon-date-picker>
            </div>
          </div>
        </at-core-dropdown>
      </div>
      <div id="hint"></div>
    </div>
  </template>
</dom-module>

<script>
  (function(utils) {
    utils.isChildOf = function(child, parent) {
      var isChild = false;
      var iterElem = child ? child : null;

      while (!isChild && iterElem !== null && iterElem.nodeType !== 9) {
        isChild = iterElem === parent;
        iterElem = iterElem.parentElement;
      }

      return isChild;
    }
    utils.isString = function (obj) {
      return Object.prototype.toString.call(obj) === "[object String]";
    }
  }(window.afDateRangeUtils = window.afDateRangeUtils || {}));

  Polymer({
    is: 'at-form-daterange',
    behaviors: [ Tangere.behaviors.i18n, Tangere.behaviors.formUIGeneric ],
    properties: {
      label: {
        type: String,
        value: '',
        title: 'Label'
      },

      hideLabel: {
        type: Boolean,
        value: false,
        observer: '_hideLabelChanged',
        title: 'Do not show the label'
      },

      disabled: {
        type: Boolean,
        value: false,
        observer: '_disabledChanged',
        title: 'Field value can not be changed'
      },

      /**
       * Hides the element. When hidden nothing is displayed for the element
       * @property hide
       * @type Boolean
       * @default false
       */
      hide: {
        type: Boolean,
        value: false,
        observer: '_hideChanged',
        title: 'Field is invisible'
      },

      required: {
        type: Boolean,
        value: false,
        observer: '_requiredChanged',
        title: 'Input required'
      },

      format: {
        type: String,
        value: '',
        observer: '_formatChanged',
        title: 'Format'
      },

      startDate: {
        type: String,
        value: '',
        notify: true,
        observer: '_startDateChanged'
      },

      endDate: {
        type: String,
        value: '',
        notify: true,
        observer: '_endDateChanged'
      },

      value: {
        type: String,
        computed: 'computeValue(startDate, endDate)',
        notify: true,
        isReadOnly: true,
        title: 'Value'
      }
    },
    $meta: [{
      title: "Daterange",
      type: "daterange",
      events: [ "value-changed" ]
    }],

    _hideLabelChanged: function (newValue, oldValue) {
      var label = this.$.label;
      this.toggleClass("hidden", newValue, label);
    },

    ready: function () {

      this._internalFormat = this._localizedFormat("date");
      this._lastFormatUsedForParsing = this._internalFormat;
      var self = this;
      var coreDropdown = this.$.coreDropdown;

      this._boundResizeHandler = function() {};
      this.orientation = 'horizontal';
      var dropdown = this.$.dropdown;
      var coreDropdown = this.$.coreDropdown;
      this.toggleClass('horizontal', this.orientation === 'horizontal', dropdown);
      this.toggleClass('vertical', this.orientation === 'vertical', dropdown);
      var contentContainer = this.$.contentContainer;
      var resizeUnboundHandler = function(event) {
        var windowWidth = contentContainer.getBoundingClientRect().width;
        var dropdownWidth = dropdown.getBoundingClientRect().width;
        var dropdownLeft = dropdown.getBoundingClientRect().left;
        if (this.orientation === 'horizontal') {
          if (dropdownWidth > windowWidth) {
            this.toggleClass('horizontal', false, dropdown);
            this.toggleClass('vertical', true, dropdown);
            this.orientation = 'vertical';
          } else {
            this.toggleClass('horizontal', true, dropdown);
            this.toggleClass('vertical', false, dropdown);
          }
        } else if (this.orientation === 'vertical') {
          if (dropdownWidth * 3 > windowWidth) {
            this.toggleClass('horizontal', false, dropdown);
            this.toggleClass('vertical', true, dropdown);
          } else {
            this.toggleClass('horizontal', true, dropdown);
            this.toggleClass('vertical', false, dropdown);
            this.orientation = 'horizontal';
          }
        }
        if (coreDropdown.isOpen()) {
          coreDropdown.hide();
          coreDropdown.show();
        }
      }

      this._isReady = true;
    },

    _disabledChanged: function (newValue, oldValue) {
      var atContainer = this.$.atContainer;
      this.toggleClass('disabled', newValue, atContainer);

      if (this._isReady) {
        this.validate();
      }
    },


    _hideChanged: function (newValue, oldValue) {
      var wrapper = this.$.atContainer;
      this.toggleClass('hidden', newValue, wrapper);
      if (this._isReady) {
        this.validate();
      }

      this.validate();
    },

    _requiredChanged: function (newValue, oldValue) {
      if (this._isReady) {
        this.validate();
      }
    },

    _formatChanged: function (newValue, oldValue) {
      var format = newValue;
      if (format) {
        if (!this._containsChars(['Y', 'M', 'D'], format) || this._containsChars(['h', 'm', 's'], format)) {
          // set format to the default format for date
          format = this._internalFormat;
          this._lastFormatUsedForParsing = this._internalFormat;
          // log the error
          console.log('Value ' + newValue + ' is not a valid format for date. Using default, ' + format + ', format instead.');
        }
        this.format = format;
        this.fire('format-changed', {
          value: format
        });
        this._internalFormat = format;

        /*
         * reformat startDate and endDate to match new format
         */
        if (this._lastFormatUsedForParsing) {
          var newStartDate;
          var startMoment = moment(this.startDate, this._lastFormatUsedForParsing);
          if (startMoment.isValid()) {
            newStartDate = startMoment.format(format);
          }

          var newEndDate;
          var endMoment = moment(this.endDate, this._lastFormatUsedForParsing);
          if (endMoment.isValid()) {
            newEndDate = endMoment.format(format);
          }
          this._lastFormatUsedForParsing = format;
          this.startDate = newStartDate;
          this.endDate = newEndDate;
        }
      }
    },
    /**
     * checks if source contains any of the chars
     * @param {Array} chars
     * @param {String} source
     */
    _containsChars: function(chars, source) {
      var result = false;
      chars.forEach(function(char, index) {
        result = result || source.indexOf(char) !== -1;
      });
      return result;
    },

    validate: function (showError) {
      return true;
    },

    _updateUIValidState: function (isValid) {
      var label = this.$.label;
      this.toggleClass('error', !isValid, label);
      var contentContainer = this.$.contentContainer;
      this.toggleClass('error', !isValid, contentContainer);
    },

    _startDateChanged: function (newValue, oldValue) {
      if (this._isReady) {
        this.validate();
      }
    },
    _endDateChanged: function (newValue, oldValue) {
      if (this._isReady) {
        this.validate();
      }
    },

    // value is read only
    set value(newValue) {},

    // compute value computes the value from startDate and endDate
    computeValue: function (startDate, endDate) {
      var valueStringTemplate = this.T("{0} to {1}");
      var result = '';
      if (startDate === "" || endDate === "") { return result; }
      if (startDate && endDate) {
        result = valueStringTemplate.replace("{0}", startDate).replace("{1}", endDate);
      }

      return result;
    },

    open: function (evnet) {
      if (!this.disabled) {
        this.$.coreDropdown.open();
      }
    },

    close: function (event) {
      this.$.coreDropdown.close();
    },

    toggle: function (event) {
      if (!this.disabled) {
        this.$.coreDropdown.toggle(this.$.triggerRange);
      }
    },

    rangeItemClicked: function(event) {
      var value = event.target.getAttribute('value');
      this.$.coreDropdown.hide();
      this._selectedChanged(value);
    },

    _selectedChanged: function(newValue) {
       if (newValue === "") {
         return;
       }
       var activeItem = this.$$('.range-item.active');
       if (activeItem) {
         Polymer.dom(activeItem).classList.remove('active');
       }
       var calendarStart = this.$.calendarStart;
       this.toggleClass('hidden', newValue !== 'custom', calendarStart);
       var calendarEnd = this.$.calendarEnd;
       this.toggleClass('hidden', newValue !== 'custom', calendarEnd);
       if (this._boundResizeHandler !== undefined) {
         this._boundResizeHandler();
       }
       if (newValue === 'custom') {
         this.$.coreDropdown.show();
       }
       this._isInternalUpdate = true;
       switch (newValue) {
         case 'today':
           this.startDate = this._formatDate(moment());
           this.endDate = this._formatDate(moment());
           break;
         case 'yesterday':
           this.startDate = this._formatDate(moment().subtract(1, "days"));
           this.endDate = this._formatDate(moment().subtract(1, "days"));
           break;
         case 'last7days':
           this.startDate = this._formatDate(moment().subtract(6, "days"));
           this.endDate = this._formatDate(moment());
           break;
         case 'last30days':
           this.startDate = this._formatDate(moment().subtract(30, "days"));
           this.endDate = this._formatDate(moment());
           break;
         case 'thisMonth':
           this.startDate = this._formatDate(moment().startOf("month"));
           this.endDate = this._formatDate(moment().endOf("month"));
           break;
         case 'lastMonth':
           this.startDate = this._formatDate(moment().subtract(1, "months").startOf("month"));
           this.endDate = this._formatDate(moment().subtract(1, "months").endOf("month"));
           break;
         case 'custom':
           // for initialization purposes (first time) startDate and endDate are set to today
           // subject to change
           if (this.startDate === '') {
             this.startDate = this._formatDate(moment());
           }
           if (this.endDate === '') {
             this.endDate = this._formatDate(moment());
           }
           break;
       }
       this._isInternalUpdate = false;
       if (newValue) {
         var liElem = this.$$('.range-item[value=' + newValue + ']');
         if (liElem) {
           Polymer.dom(liElem).classList.add('active');
         }
       }
     },
     _formatDate: function(moment) {
       if (!this.format) {
         // this.format = this._internalFormat;
       }
       return moment.format(this._internalFormat);
     },

    _buttonIconClick: function () {
      if (!this.disabled) {
        this.$.triggerRange.focus();
      }
    },

    // *ij* the main purpose of this function is to validate startDate and endDate format when they are programmatically set
    _validateValueFormat: function(value) {
      var result = true;
      var valueParts = value.split(' to ');
      var startDate = valueParts[0];
      var endDate = valueParts[1];
      var dateFormat = this._internalFormat;

      var startDateValid = true;
      var endDateValid = true;

      if (value === '') {
        return true;
      }

      if (startDate !== undefined && startDate !== '') {
        startDateValid = moment(startDate, dateFormat).isValid();
      }

      if (endDate !== undefined && endDate !== '') {
        endDateValid = moment(endDate, dateFormat).isValid();
      }

      result = result && startDateValid && endDateValid;

      if (!startDateValid) {
        this._errorMessage = this.T('Start date is in invalid format. Enter start date in format {0}', dateFormat);
      } else if (!endDateValid) {
        this._errorMessage = this.T('End date is in invalid format. Enter end date in format {0}', dateFormat);
      }

      return result;
    },

    focus: function () {
      var trigger = this.$.triggerRange;
      trigger.focus();
    },

    _getFocusableElement: function () {
      var focusable = this.$.triggerRange;
      return focusable;
    }
  });
</script>
