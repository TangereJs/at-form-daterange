<script src="../moment/min/moment.min.js"></script>
<script src="../moment-timezone/builds/moment-timezone-with-data.min.js"></script>

<link rel="import" href="../tangere/Tangere.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="at-form-daterange-calendar.html">
<link rel="import" href="at-form-daterange-positioning.html">
<link rel="import" href="../layout/layout.html">

<dom-module id="at-form-daterange-dropdown">
  <template>
    <style>
      polymer-date-picker-calendar {
        display: block;
        float: left;
      }

      #target {
        z-index: 1000;
      }

      #rangeDiv {
        position: absolute;
      }

      #nonrangeDiv {
        position: absolute;
      }

      .daterangepicker {
        background-color: var(--at-form-daterange-dropdown-background-color);
        position: relative;
        top: 4px;
        min-width: 228px;
      }

      .daterangepicker:before {
        content: '';
        position: absolute;
        top: -2px;
        display: inline-block;
        @apply(--at-form-daterange-dropdown-border-before);
      }

      .daterangepicker:after {
        content: '';
        position: absolute;
        top: -1px;
        display: inline-block;
        @apply(--at-form-daterange-dropdown-border-after);
      }

      .daterangepicker.opensleft .ranges {}

      .daterangepicker.opensleft:before {
        right: 19px;
      }

      .daterangepicker.opensleft:after {
        right: 20px;
      }

      .daterangepicker.opensright .ranges {}

      .daterangepicker.opensright:before {
        left: 19px;
      }

      .daterangepicker.opensright:after {
        left: 20px;
      }

      .daterangepicker .ranges {
        padding: 8px;
        margin: 4px;
        background-color: var(--at-form-daterange-ranges-background-color);
        @apply(--at-form-daterange-ranges-border);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.176);
        min-width: 207px;
      }

      .daterangepicker .ranges ul {
        margin: 0;
        padding: 0;
        list-style-type: none;
      }

      .daterangepicker .ranges ul li {
        padding: 5px 12px;
        margin-bottom: 8px;
        font-size: 13px;
        cursor: pointer;
        border-radius: 5px;
        color: var(--at-form-daterange-ranges-list-item-text-color);
        background-color: var(--at-form-daterange-ranges-list-item-text-background-color);
      }

      .daterangepicker .ranges ul li.active,
      .daterangepicker .ranges ul li:hover {
        color: var(--at-form-daterange-ranges-list-item-text-color-active);
        background: var(--at-form-daterange-ranges-list-item-text-background-color-active);
      }

      .hidden {
        display: none;
        visibility: hidden;
      }
    </style>

    <div id="target" class="daterangepicker opensright" style="display: none;" on-blur="close">
      <div id="rangeDiv" class="horizontal layout">
        <div hidden$="{{!showRanges}}" class="ranges">
          <ul>
            <li on-click="menuItemClicked" value="today">{{T("Today")}}</li>
            <li on-click="menuItemClicked" value="yesterday">{{T("Yesterday")}}</li>
            <li on-click="menuItemClicked" value="last7days">{{T("Last 7 Days")}}</li>
            <li on-click="menuItemClicked" value="last30days">{{T("Last 30 Days")}}</li>
            <li on-click="menuItemClicked" value="thisMonth">{{T("This Month")}}</li>
            <li on-click="menuItemClicked" value="lastMonth">{{T("Last Month")}}</li>
            <li on-click="menuItemClicked" value="custom">{{T("Custom")}}</li>
          </ul>
        </div>
        <div>
          <at-form-daterange-calendar id="calendarStart" start hidden="true" format="[[format]]"></at-form-daterange-calendar>
        </div>
        <div>
          <at-form-daterange-calendar id="calendarEnd" end hidden="true" format="[[format]]"></at-form-daterange-calendar>
        </div>
      </div>
    </div>
    <!-- *ij* to solve the focus / blur problems i use this hack here -->
    <input type="text" id="focusBlurDummy" style="position: absolute; left: -5000px;" />
  </template>
</dom-module>
<script>
  Polymer({
    is: "at-form-daterange-dropdown",
    behaviors: [ Tangere.behaviors.i18n ],
    properties: {
      startDate: {
        type: String,
        value: ''
      },
      endDate: {
        type: String,
        value: ''
      },
      selected: {
        type: String,
        value: '',
        observer: 'selectedChanged'
      },
      showRanges: {
        type: Boolean,
        value: false
      },
      timezone: {
        type: String,
        value: ''
      },
      orientation: {
        type: String,
        value: 'horizontal'
      },
      format: {
        type: String,
        value: ''
      }
    },
    ready: function() {
      if (this.format === "") {
        this.format = this._localizedFormat("date");
      }

      this._boundResizeHandler = function() {};

      this.toggleClass('horizontal', this.orientation === 'horizontal', this.$.rangeDiv);
      this.toggleClass('vertical', this.orientation === 'vertical', this.$.rangeDiv);

      var resizeUnboundHandler = function(event) {
        var windowWidth = window.innerWidth;
        var dropdownWidth = this.$.rangeDiv.getBoundingClientRect().width;
        var dropdownLeft = this.$.rangeDiv.getBoundingClientRect().left;
        if (this.orientation === 'horizontal') {
          if (dropdownWidth + dropdownLeft > windowWidth) {
            this.toggleClass('horizontal', false, this.$.rangeDiv);
            this.toggleClass('vertical', true, this.$.rangeDiv);
            this.orientation = 'vertical';
          } else {
            this.toggleClass('horizontal', true, this.$.rangeDiv);
            this.toggleClass('vertical', false, this.$.rangeDiv);
          }
        } else if (this.orientation === 'vertical') {
          if (dropdownWidth * 3 + dropdownLeft > windowWidth) {
            this.toggleClass('horizontal', false, this.$.rangeDiv);
            this.toggleClass('vertical', true, this.$.rangeDiv);
          } else {
            this.toggleClass('horizontal', true, this.$.rangeDiv);
            this.toggleClass('vertical', false, this.$.rangeDiv);
            this.orientation = 'horizontal';
          }
        }
      }

      var boundResizeHandler = resizeUnboundHandler.bind(this);
      window.addEventListener('resize', boundResizeHandler);
      this._boundResizeHandler = boundResizeHandler;

      var calendarStart = this.$.calendarStart;
      var calendarEnd = this.$.calendarEnd;
      var self = this;
      calendarStart.addEventListener('dates-updated', function(event) {
        event.stopPropagation();
        var newValue = event.detail.value;
        self._updateStartDate(newValue.startDate);
        calendarStart.initializeDates(self.startDate, self.endDate);
        calendarEnd.initializeDates(self.startDate, self.endDate);
        self._fireDatesUpdatedEvent();
      });
      calendarEnd.addEventListener('dates-updated', function(event) {
        event.stopPropagation();
        var newValue = event.detail.value;
        self._updateEndDate(newValue.endDate);
        calendarStart.initializeDates(self.startDate, self.endDate);
        calendarEnd.initializeDates(self.startDate, self.endDate);
        self._fireDatesUpdatedEvent();
      });
    },
    open: function() {
      this.$.target.style.display = "block";
      // this.selectedChanged(this.selected, this.selected);
      this._boundResizeHandler();
    },
    close: function() {
      this.$.target.style.display = "none";
      // *ij* to solve the focus / blur problems i use this hack here
      // http://stackoverflow.com/questions/2520650/how-do-you-clear-the-focus-in-javascript
      this.$.focusBlurDummy.focus();
      this.$.focusBlurDummy.blur();
    },
    toggle: function() {
      if (this.$.target.style.display === "none") {
        this.open();
      } else {
        this.close();
      }
    },
    newMoment: function() {
      if (this.timezone) {
        if (moment.tz) {
          return moment().tz(this.timezone);
        } else {
          return moment();
        }
      } else {
        return moment();
      }
    },
    // this function handles the click event on menu items
    menuItemClicked: function(event) {
      var value = event.target.getAttribute('value');

      if (value !== 'custom') {
        this.close();
      }

      this.selected = value;
    },
    selectedChanged: function(newValue, oldValue) {
      if (newValue === "") { return; }

      var activeItem = this.$$('li.active');

      if (activeItem) {
        Polymer.dom(activeItem).classList.remove('active');
      }
      var calendarStart = this.$.calendarStart;
      this.toggleAttribute('hidden', this.selected !== 'custom', calendarStart);
      var calendarEnd = this.$.calendarEnd;
      this.toggleAttribute('hidden', this.selected !== 'custom', calendarEnd);

      switch (this.selected) {
        case 'today':
          this.startDate = this._formatDate(this.newMoment());
          this.endDate = this._formatDate(this.newMoment());
          break;
        case 'yesterday':
          this.startDate = this._formatDate(this.newMoment().subtract(1, "days"));
          this.endDate = this._formatDate(this.newMoment().subtract(1, "days"));
          break;
        case 'last7days':
          this.startDate = this._formatDate(this.newMoment().subtract(6, "days"));
          this.endDate = this._formatDate(this.newMoment());
          break;
        case 'last30days':
          this.startDate = this._formatDate(this.newMoment().subtract(30, "days"));
          this.endDate = this._formatDate(this.newMoment());
          break;
        case 'thisMonth':
          this.startDate = this._formatDate(this.newMoment().startOf("month"));
          this.endDate = this._formatDate(this.newMoment().endOf("month"));
          break;
        case 'lastMonth':
          this.startDate = this._formatDate(this.newMoment().subtract(1, "months").startOf("month"));
          this.endDate = this._formatDate(this.newMoment().subtract(1, "months").endOf("month"));
          break;
        case 'custom':
          // for initialization purposes (first time) startDate and endDate are set to today
          // subject to change
          if (this.startDate === '') {
            this.startDate = this._formatDate(this.newMoment());
          }
          if (this.endDate === '') {
            this.endDate = this._formatDate(this.newMoment());
          }
          break;
      }

      if (this.selected) {
        var liElem = this.$$('li[value=' + this.selected + ']');
        if (liElem) {
          Polymer.dom(liElem).classList.add('active');
        }
      }

      calendarStart.initializeDates(this.startDate, this.endDate);
      calendarEnd.initializeDates(this.startDate, this.endDate);

      this._fireDatesUpdatedEvent();
    },
    _formatDate: function(moment) {
      if (this.format === "") {
        this.format = this._localizedFormat("date");
      }
      // when component is initialized for unknown reasons timezone property is not deserialized correctly
      // this is detected with this.timezone === undefined; however attribute is still here and its value can be retreived
      // in instances after initialization timezone property is ok
      // if timezone property is null (which happens when timezone attribute is not set)
      // I set it to default value of 'America/NewYork'
      // This should also be reviewed and corrected when polymer team FIXES polymer because it sucks now. (13.052015)
      this.timezone = this.timezone === undefined ? this.getAttribute('timezone') : this.timezone;
      if (this.timezone === null) {
        this.timezone = 'America/New_York';
      }
      if (moment.tz) {
        return moment.tz(this.timezone).format(this.format);
      } else {
        console.log('moment.tz function is undefined');
        return moment.format(this.format);
      }
    },
    _updateStartDate: function (newValue) {
      this.startDate = newValue;
      var startMomemt = moment(newValue, this.format);
      var endMoment = moment();
      if (this.endDate) {
        endMoment = moment(this.endDate, this.format);
      }

      if (startMomemt.isAfter(endMoment)) {
        this.startDate = this.endDate;
        this.endDate = newValue;
      }
    },
    _updateEndDate: function (newValue) {
      this.endDate = newValue;
      var startMoment = moment();
      if (this.startDate) {
        startMoment = moment(this.startDate, this.format);
      }
      var newMomemt = moment(newValue, this.format);

      if (newMomemt.isBefore(startMoment)) {
        this.endDate = this.startDate;
        this.startDate = newValue;
      }
    },
    _fireDatesUpdatedEvent: function () {
      this.fire('dates-updated', {
        value: {
          startDate: this.startDate,
          endDate: this.endDate
        }
      });
    },
    initializeDates: function (startDate, endDate) {
      var startMoment = moment(startDate);
      var endMoment = moment(endDate);

      if (startMoment > endMoment) {
        this.startDate = endDate;
        this.endDate = startDate;
      } else if (endMoment < startMoment) {
        this.startDate = endDate;
        this.endDate = startDate;
      }

      this.$.calendarStart.initializeDates(this.startDate, this.endDate);
      this.$.calendarEnd.initializeDates(this.startDate, this.endDate);
    }
  });
</script>
