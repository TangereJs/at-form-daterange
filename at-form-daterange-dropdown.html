<script src="../moment/min/moment.min.js"></script>
<script src="../moment-timezone/builds/moment-timezone-with-data.min.js"></script>

<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="../at-carbon-date-picker/at-carbon-date-picker.html">

<link rel="import" href="../layout/layout.html">

<dom-module id="at-form-daterange-dropdown">
  <template>
    <style>
      polymer-date-picker-calendar {
        display: block;
        float: left;
      }

      #target {
        z-index: 1000;
      }

      #rangeDiv {
        position: absolute;
      }

      .daterangepicker {
        background-color: var(--at-form-daterange-dropdown-background-color);
        position: relative;
        top: 4px;
        min-width: 175px;
      }

      .daterangepicker:before {
        content: '';
        position: absolute;
        top: -2px;
        display: inline-block;
        @apply(--at-form-daterange-dropdown-border-before);
      }

      .daterangepicker:after {
        content: '';
        position: absolute;
        top: -1px;
        display: inline-block;
        @apply(--at-form-daterange-dropdown-border-after);
      }

      .daterangepicker.opensleft .ranges {}

      .daterangepicker.opensleft:before {
        right: 19px;
      }

      .daterangepicker.opensleft:after {
        right: 20px;
      }

      .daterangepicker.opensright .ranges {}

      .daterangepicker.opensright:before {
        left: 19px;
      }

      .daterangepicker.opensright:after {
        left: 20px;
      }

      .daterangepicker .ranges {
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        padding: 4px 8px;
        margin: 4px;
        background-color: var(--at-form-daterange-ranges-background-color);
        @apply(--at-form-daterange-ranges-border);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.176);
        min-width: 175px;
      }

      .range-item {
        padding: 4px 8px;
        margin: 2px 0;
        cursor: pointer;
        border-radius: 5px;
        @apply(--at-form-label-font);
        background-color: var(--at-form-daterange-calendar-item-hover-background-color);
      }

      .daterangepicker .ranges .range-item.active,
      .daterangepicker .ranges .range-item:hover {
        color: var(--at-form-daterange-calendar-active-item-text-color);
        background: var(--at-form-daterange-calendar-active-item-background-color);
      }

      .hidden {
        display: none;
        visibility: hidden;
      }
    </style>

    <div id="target" class="daterangepicker opensright" style="display: none;" on-blur="close">
      <div id="rangeDiv" class="horizontal layout">
        <div hidden$="{{!showRanges}}" class="ranges">
          <div class="range-item" on-click="menuItemClicked" value="today">{{T("Today")}}</div>
          <div class="range-item" on-click="menuItemClicked" value="yesterday">{{T("Yesterday")}}</div>
          <div class="range-item" on-click="menuItemClicked" value="last7days">{{T("Last 7 Days")}}</div>
          <div class="range-item" on-click="menuItemClicked" value="last30days">{{T("Last 30 Days")}}</div>
          <div class="range-item" on-click="menuItemClicked" value="thisMonth">{{T("This Month")}}</div>
          <div class="range-item" on-click="menuItemClicked" value="lastMonth">{{T("Last Month")}}</div>
          <div class="range-item" on-click="menuItemClicked" value="custom">{{T("Custom")}}</div>
        </div>
        <div>
          <at-carbon-date-picker id="calendarStart" mode="start-range" hidden="true" start-date="{{startDate}}" end-date="{{endDate}}" format="[[format]]"></at-carbon-date-picker>
        </div>
        <div>
          <at-carbon-date-picker id="calendarEnd"  mode="end-range" hidden="true" start-date="{{startDate}}" end-date="{{endDate}}" format="[[format]]"></at-carbon-date-picker>
        </div>
      </div>
    </div>
    <!-- *ij* to solve the focus / blur problems i use this hack here -->
    <input type="text" id="focusBlurDummy" style="position: absolute; left: -5000px;" />
  </template>
</dom-module>
<script>
  Polymer({
    is: "at-form-daterange-dropdown",
    behaviors: [Tangere.behaviors.i18n],
    properties: {
      startDate: {
        type: String,
        value: '',
        notify: true,
        observer: 'startDateChanged'
      },
      endDate: {
        type: String,
        value: '',
        notify: true,
        observer: 'endDateChanged'
      },
      selected: {
        type: String,
        value: '',
        observer: 'selectedChanged'
      },
      showRanges: {
        type: Boolean,
        value: false
      },
      timezone: {
        type: String,
        value: ''
      },
      orientation: {
        type: String,
        value: 'horizontal'
      },
      format: {
        type: String,
        value: ''
      }
    },
    ready: function() {
      if (!this.format) {
        this.format = this._localizedFormat("date");
      }

      this._boundResizeHandler = function() {};

      this.toggleClass('horizontal', this.orientation === 'horizontal', this.$.rangeDiv);
      this.toggleClass('vertical', this.orientation === 'vertical', this.$.rangeDiv);

      var resizeUnboundHandler = function(event) {
        var windowWidth = window.innerWidth;
        var dropdownWidth = this.$.rangeDiv.getBoundingClientRect().width;
        var dropdownLeft = this.$.rangeDiv.getBoundingClientRect().left;
        if (this.orientation === 'horizontal') {
          if (dropdownWidth + dropdownLeft > windowWidth) {
            this.toggleClass('horizontal', false, this.$.rangeDiv);
            this.toggleClass('vertical', true, this.$.rangeDiv);
            this.orientation = 'vertical';
          } else {
            this.toggleClass('horizontal', true, this.$.rangeDiv);
            this.toggleClass('vertical', false, this.$.rangeDiv);
          }
        } else if (this.orientation === 'vertical') {
          if (dropdownWidth * 3 + dropdownLeft > windowWidth) {
            this.toggleClass('horizontal', false, this.$.rangeDiv);
            this.toggleClass('vertical', true, this.$.rangeDiv);
          } else {
            this.toggleClass('horizontal', true, this.$.rangeDiv);
            this.toggleClass('vertical', false, this.$.rangeDiv);
            this.orientation = 'horizontal';
          }
        }
      }

      var boundResizeHandler = resizeUnboundHandler.bind(this);
      window.addEventListener('resize', boundResizeHandler);
      this._boundResizeHandler = boundResizeHandler;
    },
    open: function() {
      this.$.target.style.display = "block";
      // this.selectedChanged(this.selected, this.selected);
      this._boundResizeHandler();
    },
    close: function() {
      this.$.target.style.display = "none";
      // *ij* to solve the focus / blur problems i use this hack here
      // http://stackoverflow.com/questions/2520650/how-do-you-clear-the-focus-in-javascript
      this.$.focusBlurDummy.focus();
      this.$.focusBlurDummy.blur();
    },
    toggle: function() {
      if (this.$.target.style.display === "none") {
        this.open();
      } else {
        this.close();
      }
    },
    newMoment: function() {
      if (this.timezone) {
        if (moment.tz) {
          return moment().tz(this.timezone);
        } else {
          return moment();
        }
      } else {
        return moment();
      }
    },
    // this function handles the click event on menu items
    menuItemClicked: function(event) {
      var value = event.target.getAttribute('value');

      if (value !== 'custom') {
        this.close();
      }

      this.selected = value;
    },
    selectedChanged: function(newValue, oldValue) {
      if (newValue === "") {
        return;
      }

      var activeItem = this.$$('.range-item.active');

      if (activeItem) {
        Polymer.dom(activeItem).classList.remove('active');
      }
      var calendarStart = this.$.calendarStart;
      this.toggleAttribute('hidden', this.selected !== 'custom', calendarStart);
      var calendarEnd = this.$.calendarEnd;
      this.toggleAttribute('hidden', this.selected !== 'custom', calendarEnd);

      this._isInternalUpdate = true;
      switch (this.selected) {
        case 'today':
          this.startDate = this._formatDate(this.newMoment());
          this.endDate = this._formatDate(this.newMoment());
          break;
        case 'yesterday':
          this.startDate = this._formatDate(this.newMoment().subtract(1, "days"));
          this.endDate = this._formatDate(this.newMoment().subtract(1, "days"));
          break;
        case 'last7days':
          this.startDate = this._formatDate(this.newMoment().subtract(6, "days"));
          this.endDate = this._formatDate(this.newMoment());
          break;
        case 'last30days':
          this.startDate = this._formatDate(this.newMoment().subtract(30, "days"));
          this.endDate = this._formatDate(this.newMoment());
          break;
        case 'thisMonth':
          this.startDate = this._formatDate(this.newMoment().startOf("month"));
          this.endDate = this._formatDate(this.newMoment().endOf("month"));
          break;
        case 'lastMonth':
          this.startDate = this._formatDate(this.newMoment().subtract(1, "months").startOf("month"));
          this.endDate = this._formatDate(this.newMoment().subtract(1, "months").endOf("month"));
          break;
        case 'custom':
          // for initialization purposes (first time) startDate and endDate are set to today
          // subject to change
          if (this.startDate === '') {
            this.startDate = this._formatDate(this.newMoment());
          }
          if (this.endDate === '') {
            this.endDate = this._formatDate(this.newMoment());
          }
          break;
      }
      this._isInternalUpdate = false;

      if (this.selected) {
        var liElem = this.$$('.range-item[value=' + this.selected + ']');
        if (liElem) {
          Polymer.dom(liElem).classList.add('active');
        }
      }
    },
    _formatDate: function(moment) {
      if (!this.format) {
        this.format = this._localizedFormat("date");
      }
      // when component is initialized for unknown reasons timezone property is not deserialized correctly
      // this is detected with this.timezone === undefined; however attribute is still here and its value can be retreived
      // in instances after initialization timezone property is ok
      // if timezone property is null (which happens when timezone attribute is not set)
      // I set it to default value of 'America/NewYork'
      // This should also be reviewed and corrected when polymer team FIXES polymer because it sucks now. (13.052015)
      this.timezone = this.timezone === undefined ? this.getAttribute('timezone') : this.timezone;
      if (this.timezone === null) {
        this.timezone = 'America/New_York';
      }
      if (moment.tz) {
        return moment.tz(this.timezone).format(this.format);
      } else {
        console.log('moment.tz function is undefined');
        return moment.format(this.format);
      }
    },
    startDateChanged: function(newValue) {
      if (this._isInternalUpdate) {
        return;
      }
      if (newValue === "") {
        return;
      }
      var startMomemt = moment(newValue, this.format);
      if (startMomemt.isValid()) {
        if (this.endDate) {
          endMoment = moment(this.endDate, this.format);

          if (startMomemt.isAfter(endMoment)) {
            this._isInternalUpdate = true;
            this.startDate = this.endDate;
            this.endDate = newValue;
            this._isInternalUpdate = false;
          }
        }
      }
    },
    endDateChanged: function(newValue) {
      if (this._isInternalUpdate) {
        return;
      }
      if (newValue === "") {
        return;
      }
      var endMomemt = moment(newValue, this.format);
      if (this.startDate) {
        startMoment = moment(this.startDate, this.format);

        if (endMomemt.isBefore(startMoment)) {
          this._isInternalUpdate = true;
          this.endDate = this.startDate;
          this.startDate = newValue;
          this._isInternalUpdate = false;
        }
      }
    }
  });
</script>
